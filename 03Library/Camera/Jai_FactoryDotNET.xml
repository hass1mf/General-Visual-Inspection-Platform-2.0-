<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jai_FactoryDotNET</name>
    </assembly>
    <members>
        <member name="T:Jai_FactoryDotNET.CNodeHandler">
            <summary>
            The <c>CNodeHandler</c> object
            </summary>    
        </member>
        <member name="M:Jai_FactoryDotNET.CNodeHandler.GetNodeValue(System.IntPtr,System.IntPtr,System.String)">
            <summary>
            Get the current value of a named GenICam node
            
            This function will return the current value of a GenICam node. The return value type will depend on the node type.
            </summary>
            <param name="hTL">Transport layer handle</param>
            <param name="hHandle">Input handle</param>
            <param name="nodeName">Name of the GenICam node. This name has to be the GenICam name - not the Display Name</param>
            <returns>value object</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CNodeHandler.GetNode(System.IntPtr,System.String)">
            <summary>
            Get a GenICam node by name
            
            This function will search for a GenICam node with the specified name
            </summary>
            <param name="hTL">Transport layer handle</param>
            <param name="nodeName">Name of the GenICam node. This name has to be the GenICam name - not the Display Name</param>
            <returns>CNode object if the GenICam node is found</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CNodeHandler.GetSubFeatures(System.IntPtr,System.String)">
            <summary>
            Get a list of sub-features under a named parent GenICam node
            </summary>
            <param name="hTL">Transport layer handle</param>
            <param name="ParentFeatureName">Name of the parent feature</param>
            <returns>A List of CNode-type object</returns>
        </member>
        <member name="T:Jai_FactoryDotNET.CLocalDeviceSettings">
            <summary>
            Summary description for CameraSettings.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_EnableMulticasting">
            <summary>
            Enable Multi-casting.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_MulticastAddress">
            <summary>
            Multi-cast address.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_AcquisitionBufferCount">
            <summary>
            Acquisition Buffer Count.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_EnablePacketResend">
            <summary>
            Enable Packet Resend.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_PassCorruptFrames">
            <summary>
            Pass Corrupt Frames.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_ReadWriteAckTimeout">
            <summary>
            Read Write Ack Timeout.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_ReadWriteRetryTimeout">
            <summary>
            Read Write Retry Timeout.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_GevControlTimeout">
            <summary>
            Read Write Pending Timeout.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_GevControlRetryCount">
            <summary>
            Read Write Retry Count.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_ManifestEntrySelector">
            <summary>
            Manifest Entry Selector.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDeviceSettings.m_DeviceEndianess">
            <summary>
            Device Endianess.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDeviceSettings.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDeviceSettings.#ctor(Jai_FactoryDotNET.CLocalDeviceSettings)">
            <summary>
            Constructor that copies the contents of another CameraSettings
            </summary>
            <param name="SourceSettings">Source CameraSettings object to copy from</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDeviceSettings.LoadSettings(Jai_FactoryDotNET.CLocalDeviceSettings@,System.String)">
            <summary>
            Load CameraSettings settings from XML file
            </summary>
            <param name="DesinationSettings">Reference to CameraSettings object to update with values read from XML file</param>
            <param name="Filename">Filename of the RGB settings XML file</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDeviceSettings.SaveSettings(Jai_FactoryDotNET.CLocalDeviceSettings@,System.String)">
            <summary>
            Save CameraSetting to XML file
            </summary>
            <param name="SourceSettings">Reference to RGB setting to be saved</param>
            <param name="Filename">Filename of the RGB settings XML file</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper">
            
             \brief Wrapper class for the JAI SDK \c Jai_Factory.dll functions
             
             The wrapper class encapsulates the \c Jai_factory.dll using pInvoke calls from managed to unmanaged code
             All functions from \c Jai_Factory.dll will be exposed using \c Jai_FactoryDotNET.Jai_FactoryWrapper \n
             Instead of using this wrapper directly we recommend to use the \c CFactory, \c CCamera and \c CNode classes instead.
             They are using the \c Jai_FactoryDotNET.Jai_FactoryWrapper internally to create an object-oriented way of controlling the cameras instead
             \sa \c CFactory, \c CCamera, \c CNode 
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.GetFactoryErrorString(Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError)">
            <summary>
            Return a string that gives more explanation about the Factory Error code
            </summary>
            <param name="error">Error code returned from one of the factory methods</param>
            <returns>String representation of the Factory Error Code</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_Open(System.String,System.IntPtr@)">
            <summary>
            Open the factory and return a valid handle.
            
            If the Registry file name is left empty then the default registry file will be used.
            </summary>
            <param name="RegistryFileName">A string with the file name and path to the registry database that the user want to use</param>
            <param name="FactoryHandle">A reference to where the valid factory handle should be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_Close(System.IntPtr)">
            <summary>
            Close a previously opened factory handle
            
            When the factory is closed the underlaying transport layer and interfaces will be automatically closed and released as well
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_Open(System.String,System.IntPtr@)"/>
            <param name="FactoryHandle">Valid factory handle</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_GetInfo(Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryInfoType,System.Text.StringBuilder,System.Int32@)">
             <summary>
             Get information about the <c>Jai_Factory.dll</c>
             </summary>
             <example>
             <code>
             // C# Sample demonstrating how to read the version information from the factory
             public String Version
             {
                get
                {
                    StringBuilder infoString = new StringBuilder(100);
                    int bufferSize = infoString.Capacity;
                    if (factoryHandle != null)
                        J_Factory_GetInfo(EFactoryInfoType.Version, infoString, ref bufferSize);
            
                    return infoString.ToString();
                }
             }
             </code>
             </example>
             <param name="InfoType">The type of information from the factory that is requested</param>
             <param name="InfoString">A Stringbuilder with space for the requested information</param>
             <param name="BufferSize">The capacity of the StringBuilder. The size of the information string will be returned</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_UpdateCameraList(System.IntPtr,System.Boolean@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_GetNumOfCameras(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of cameras found during Device Discovery with <c>J_Factory_UpdateCameraList()</c>.
            
            It is important to note that the same physical camera might show up multiple times if more
            than one driver is installed and active. Normally both the SocketDriver and the FilterDriver will
            be installed and if for instance a single camera is present on the network then the
            <c>J_Factory_UpdateCameraList()</c> function will find it twice - once via the SocketDriver and
            once via the FilterDriver and <c>J_Factory_GetNumOfCameras()</c> will return the number 2. It is then
            possible for the application to select which driver to use for the connection by opening the camera
            via a specific camera ID returned by <c>J_Factory_GetCameraIDByIndex()</c> using either index 0 or index 1.
            In order to determine the driver type used the application has to parse the camera ID string and 
            search for 'INT=>SD' if it is the SocketDriver and 'INT=>FD' if it is the FilterDriver.
            </summary>
            <param name="FactoryHandle">Valid factory handle</param>
            <param name="NumOfCameras">Returns the number of cameras in the camera list create by the <c>J_Factory_UpdateCameraList()</c> </param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_GetCameraIDByIndex(System.IntPtr,System.Int32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get a string that uniquely identifies the camera, interface and the transport layer
            
            This string will be used to open the camera later on with <c>J_Camera_Open()</c>
            ex: "TL->GevTL::INT->FD::MAC::...::DEV->CV-A10GE"
            
            It is important to note that the same physical camera might show up multiple times if more
            than one driver is installed and active. Normally both the SocketDriver and the FilterDriver will
            be installed and if for instance a single camera is present on the network then the
            <c>J_Factory_UpdateCameraList()</c> function will find it twice - once via the SocketDriver and
            once via the FilterDriver and <c>J_Factory_GetNumOfCameras()</c> will return the number 2. It is then
            possible for the application to select which driver to use for the connection by opening the camera
            via a specific camera ID returned by <c>J_Factory_GetCameraIDByIndex()</c> using either index 0 or index 1.
            In order to determine the driver type used the application has to parse the camera ID string and 
            search for 'INT=>SD' if it is the SocketDriver and 'INT=>FD' if it is the FilterDriver.
            </summary>
            <param name="FactoryHandle">Valid factory handle</param>
            <param name="Index">The index of the camera into the camera list generated by <c>J_Factory_UpdateCameraList()</c> </param>
            <param name="CameraID">Reference to a StringBuilder to put the string</param>
            <param name="Size">The capacity of the StringBuilder. The length of the CameraID will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_GetCameraInfo(System.IntPtr,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType,System.Text.StringBuilder,System.UInt32@)">
             <summary>
             Get detailed information about a camera.
             
             This information will be available even before the camera connection has been established since it
             is collected during the GigE Vision Device Discovery.
             </summary>
             <example>
             <code>
             EFactoryError error = EFactoryError.Success;
            
             StringBuilder stringBuilder = new StringBuilder(512);
             uint Size = (uint)stringBuilder.Capacity;
             String Manufacturer;
             
             error = J_Factory_GetCameraInfo(factoryHandle, CameraID, ECameraInfoType.Manufacturer, stringBuilder, ref Size);
             if (error == EFactoryError.Success)
               Manufacturer = stringBuilder.ToString();
             </code>
             </example>
             <param name="FactoryHandle">Valid factory handle</param>
             <param name="CameraID">Unique camera ID. This is retrieved using \c J_Factory_GetCameraIDByIndex()</param>
             <param name="InfoType">The information type that is requested</param>
             <param name="InfoString">Reference to a StringBuilder to put the requested information into</param>
             <param name="Size">The capacity of the StringBuilder. The length of the information string will be returned</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_EnableForceIp(System.IntPtr,System.UInt32)">
            <summary>
            Set Automatic Force IP mode.
            
            If the Automatic Force IP is enabled and a camera is not accessible because it is on a wrong subnet then the
            Factory will automatically assign an IP address to this camera so the camera will be on the same subnet as the
            NIC where the camera was discovered.
            </summary>
            <param name="FactoryHandle">Handle to a valid factory object, obtained by <c>J_Factory_Open()</c> function</param>
            <param name="ForceEnabled">0: Force IP is disabled, !=0: Force IP is enabled</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_GetGenICamErrorInfo(Jai_FactoryDotNET.Jai_FactoryWrapper.GenICamErrorInfo@)">
             <summary>
             Get detailed information about GenICam errors exceptions caught in <c>Jai_Factory.dll</c>
             </summary>
             <example>
             <code>
             EFactoryError error = EFactoryError.Success;
            
             GenICamErrorInfo genICamErrorInfo = new GenICamErrorInfo;
             
             error = J_Factory_GetCameraInfo(factoryHandle, CameraID, ECameraInfoType.Manufacturer, stringBuilder, ref Size);
             if (error == EFactoryError.GenICamError)
             {
               J_Factory_GetGenICamErrorInfo(ref genICamErrorInfo);
               MessageBox.Show(genICamErrorInfo.Description);
             }
             </code>
             </example>
             <param name="genICamErrorInfo">Reference to a GenICamErrorInfo structure to put the requested information into</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_SendActionCommand(System.IntPtr,System.UInt32,System.UInt32,System.UInt32,System.IntPtr,System.UInt32@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)">
            <summary>
            Open a camera from a camera ID and return valid camera handle.
            
            The ID can be camera ID returned from the <c>J_Factory_GetCameraID()</c> or a user defined name
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Close(System.IntPtr)"/>
            <param name="FactoryHandle">Valid factory handle</param>
            <param name="CameraID">A string that holds the unique id of the camera.</param>
            <param name="CameraHandle">A reference to where the valid camera handle should be returned.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_OpenMc(System.IntPtr,System.String,System.IntPtr@,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags,System.UInt32)">
            <summary>
            Open a camera with multicasting from a camera ID and return valid camera handle.
            
            The ID can be camera ID returned from the <c>J_Factory_GetCameraID()</c> or a user defined name
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Close(System.IntPtr)"/>
            <param name="FactoryHandle">Valid factory handle</param>
            <param name="CameraID">A string that holds the unique id of the camera.</param>
            <param name="CameraHandle">A reference to where the valid camera handle should be returned.</param>
            <param name="OpenFlags">Device access Flags</param>
            <param name="McIP">Multicast IP address</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Close(System.IntPtr)">
            <summary>
            Close the camera connection
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">A valid camera handle</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetValueInt64(System.IntPtr,System.String,System.Int64@)">
            <summary>
            Get the value of a GenICam feature node as <c>Int64</c> type.
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="Value">Reference to a <c>Int64</c> variable to receive the value of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetValueDouble(System.IntPtr,System.String,System.Double@)">
            <summary>
            Get the value of a GenICam feature node as <c>double</c> type.
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IFloat</c></description></item>
            <item><description><c>EConfNodeType.IFloatReg</c></description></item>
            <item><description><c>EConfNodeType.ISwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IConverter</c></description></item>
            </list>
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="Value">Reference to a <c>double</c> variable to receive the value of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetValueString(System.IntPtr,System.String,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the value of a GenICam feature node as <c>String</c> type.
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the value can be read
            The node type can be any type. The value will automatically be converted internally in the factory
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="ValueStr">StringBuilder to place the current value of the node</param>
            <param name="SizeValueStr">Capacity of the StringBuilder. The length of the value string will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_SetValueInt64(System.IntPtr,System.String,System.Int64)">
            <summary>
            Set the value of a GenICam feature node as <c>Int64</c> type. 
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="Value">The new value to be set in the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_SetValueDouble(System.IntPtr,System.String,System.Double)">
            <summary>
            Set the value of a GenICam feature node as <c>double</c> type.
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IFloat</c></description></item>
            <item><description><c>EConfNodeType.IFloatReg</c></description></item>
            <item><description><c>EConfNodeType.ISwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IConverter</c></description></item>
            </list>
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="Value">The new value to be set in the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_SetValueString(System.IntPtr,System.String,System.String)">
            <summary>
            Set node value as a String
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the value can be set
            The node type can be any type. The value will automatically be converted internally in the factory
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="ValueStr">The new value to be set in the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_ExecuteCommand(System.IntPtr,System.String)">
            <summary>
            Execute the GenICam command
            </summary>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="NodeName">The name of the <c>EConfNodeType.ICommand</c> GenICam node</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_ReadData(System.IntPtr,System.Int64,System.IntPtr,System.UInt32@)">
            <summary>
            Read data directly from the camera
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before read and write operations can be performed
            </summary>
            <example>
            <code>
            // C# Sample reads directly from memory
            EFactoryError error = EFactoryError.Success;
            // Allocate managed buffer to hold answer
            byte[] buffer = new byte[4];
            
            // Allocate a handle to the buffer and lock the memory so the unmanaged function can write the data
            GCHandle gch = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            
            // Get the pointer to the data
            IntPtr bufferPtr = gch.AddrOfPinnedObject();
            
            // Read the data bytes
            uint size = 4;
            error = J_Camera_ReadData(cameraHandle, 0xa410, bufferPtr, ref size);
            
            // Release the pinned data
            gch.Free();
            
            if (error == EFactoryError.Success)
            { 
              ... do something with the data
            }   
            </code>
            </example>
            <param name="CameraHandle">A valid camera handle</param>
            <param name="Address">The address to be read from</param>
            <param name="Data">A pointer to a buffer to put the read data into</param>
            <param name="Size">The size of data that is read from the device</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_WriteData(System.IntPtr,System.Int64,System.Byte[],System.UInt32@)">
            <summary>
            Write data directly to the camera
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before read and write operations can be performed
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">A valide camera handle</param>
            <param name="Address">The address to be written to</param>
            <param name="Data">A buffer with the data to be written</param>
            <param name="Size">The size of data that is written to the device</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_WriteData(System.IntPtr,System.Int64,System.IntPtr,System.UInt32@)">
            <summary>
            Write data directly to the camera
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before read and write operations can be performed
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">A valide camera handle</param>
            <param name="Address">The address to be written to</param>
            <param name="Data">A pointer to a buffer containing the data</param>
            <param name="Size">The size of data that is written to the device</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetConfigInfo(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Retrieve information about the GenICam XML-file configuration loaded for the device
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">A handle to a camera device obtained using <c>J_Camera_Open()</c> </param>
            <param name="InfoType">The type of information requested</param>
            <param name="InfoString">StringBuilder to return the information into</param>
            <param name="Size">The capacity of the StringBuilder. The length of the information string will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetNumOfNodes(System.IntPtr,System.UInt32@)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetNodeByIndex(System.IntPtr,System.UInt32,System.IntPtr@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetNodeByName(System.IntPtr,System.String,System.IntPtr@)">
            <summary>
            Get node by the GenICam node name
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the nodes can be opened
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">A valid handle to a camera</param>
            <param name="NodeName">The name of the node requested</param>
            <param name="NodeHandle">The handle to the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetNumOfSubFeatures(System.IntPtr,System.String,System.UInt32@)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetSubFeatureByIndex(System.IntPtr,System.String,System.UInt32,System.IntPtr@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetFeatureByName(System.IntPtr,System.String,System.IntPtr@)">
            <summary>
            Get feature node by the name
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the feature nodes can be opened
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetName(System.IntPtr,System.Text.StringBuilder,System.UInt32@,System.UInt32)"/>
            <param name="CameraHandle">A valid handle to a camera</param>
            <param name="FeatureNodeName">The name of the node requested</param>
            <param name="NodeHandle">The handle to the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_InvalidateNodes(System.IntPtr)">
            <summary>
            Invalidates all GenICam nodes
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the feature nodes can be opened
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">A handle to a camera device</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetNumOfDataStreams(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of available Data Streams from the Camera
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the number of data streams can be read. The number of data 
            streams are used to check the available data streams so the stream channel index used in <c>J_Camera_CreateDataStream()</c>
            is within legal range.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function</param>
            <param name="NumOfDataStreams">Reference to a variable in which the number of data streams is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStream(System.IntPtr,System.UInt32,System.IntPtr@)">
             <summary>
             Create and open data stream channel to the camera
             
             The camera needs to be opened using <c>J_Camera_Open()</c> before the data stream can be created.
             </summary>
             <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
             <example>
             <code>
             private Boolean CreateStreamThread(UInt32 Channel, UInt32 BufferSize)
             {
               // Is it already created?
               if (m_streamThread != null)
                 return false;
                    
               // Open the stream channel(GVSP)
               if (StreamHandle == IntPtr.Zero)
               {
                 if (EFactoryError.Success != J_Camera_CreateDataStream(CameraHandle, Channel, out StreamHandle))
                 {
                   return false;
                 }
               }
            
               // Prepare the frame buffers (this announces the buffers to the acquisition engine)
               if (0 == PrepareBuffer(BufferSize))
               {
                 J_DataStream_Close(StreamHandle);
                 return false;
               }
            
               // Stream thread event created?
               if (StreamEvent == null)
                 StreamEvent = new AutoResetEvent(false);
               else
                 StreamEvent.Reset();
            
               // Create a Stream Thread.
               w = new Work();
               w.DataStreamHandle = StreamHandle;
               w.EnableThread = true;
               w.camera = this;
            
               ThreadStart threadDelegate = new ThreadStart(w.StreamThread);
               m_streamThread = new Thread(threadDelegate);
            
               if (m_streamThread != null)
               {
                 m_streamThread.Start();
               }
               else
               {
                 J_DataStream_Close(StreamHandle);
                 return false;
               }
            
               return true;
             }
             </code>
             </example>
             <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
             <param name="Channel">Data stream channel number. Must be within 0 and the value returned by <c>J_Camera_GetNumOfDataStreams()</c> </param>
             <param name="DSHandle">Variable in which the data streams handle is stored</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStreamMc(System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32)">
            <summary>
             Create and open data stream channel to the camera
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the data stream can be created
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_Open(System.IntPtr,System.String,System.IntPtr@)"/>
            <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
            <param name="Channel">Data stream channel number. Must be within 0 and the value returned by <c>J_Camera_GetNumOfDataStreams()</c> </param>
            <param name="DSHandle">Variable in which the data streams handle is stored</param>
            <param name="McIP">Multicast IP address. It will be ignored if it is 0</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_SaveSettings(System.IntPtr,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveSettingsFlag)">
            <summary>
            Save camera settings to disk. The format of the settings file is XML so it is possible to edit it using
            a normal text editor.
            </summary>
            <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
            <param name="SettingsFileName">String containing the file name for the settings file.</param>
            <param name="SaveFlag">Enumeration value that selects the behaviour of the Save function. See <c>ESaveSettingsFlag</c> for more information.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_LoadSettings(System.IntPtr,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ELoadSettingsFlag)">
            <summary>
            Load camera settings from disk and either validate or send the the settings to the connected camera.
            </summary>
            <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
            <param name="SettingsFileName">String containing the file name for the settings file.</param>
            <param name="LoadFlag">Enumeration value that selects the behaviour of the Load function. See <c>ELoadSettingsFlag</c> for more information.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetSettingsValidationErrorInfo(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get Camera Settings Validation error information
            </summary>
            <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
            <param name="ErrorInfoBuffer">Buffer where the detailed validation information will be returned.</param>
            <param name="Size">Pointer to a variable that contains the size of the user allocated buffer. If the size is set to 0 by the user application then this function will return the size required to hold the complete error information string. If the size is set to non-zero then it will be updated with the actual size of the string returned in ErrorInfoBuffer</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_AnnounceBuffer(System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr@)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_FlushQueue(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqQueueType)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_StartAcquisition(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStartFlags,System.UInt64)">
            <summary>
            Start the image acquisition on the stream channel
            
            The data stream needs to be created using \c J_Camera_CreateDataStream() and buffers needs to be announced using 
            <c>J_DataStream_AnnounceBuffer()</c> before acquisition can be started.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStream(System.IntPtr,System.UInt32,System.IntPtr@)"/>
            <param name="DSHandle">Handle to a valid data stream, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
            <param name="Flags">Aquisition start control flag. This parameter is currently not used in the drivers!!</param>
            <param name="NumImages">Number of images to acquire. Number of images to acquire. Use a value of 0 (or ULONG_MAX ==&gt; 0xFFFFFFFFFFFFFFFF) for continuous capture.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_StopAcquisition(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStopFlags)">
             <summary>
             Stop the image acquisition on the stream channel
             </summary>
             <example>
             <code>
             //==============================================================////
             // Terminate Stream Thread
             //==============================================================////
             Boolean TerminateStreamThread()
             {
               // Is the data stream opened?
               if (StreamHandle == IntPtr.Zero)
                 return false;
            
               // Reset the thread execution flag.
               w.EnableThread = false;
            
               // Signal the image thread to stop faster
               J_Event_ExitCondition(NewImageCondition);
            
               // Stop the image acquisition engine
               J_DataStream_StopAcquisition(StreamHandle, Jai_FactoryWrapper.EAcqStopFlags.KILL);
                 
               // Wait for the thread to end
               StreamEvent.WaitOne();
            
               // UnPrepare Buffers (this removed the buffers from the acquisition engine and frees buffers)
               UnPrepareBuffer();
            
               // Close Stream
               if (StreamHandle != IntPtr.Zero)
               {
                 Jai_FactoryWrapper.J_DataStream_Close(StreamHandle);
                 StreamHandle = IntPtr.Zero;
               }
             
               m_streamThread = null;
            
               return true;
             }
             </code>
             </example>
             <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStream(System.IntPtr,System.UInt32,System.IntPtr@)"/>
             <param name="DSHandle">Handle to a valid data stream, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
             <param name="Flags">Aquisition stop control flag. This parameter is currently not used in the Filter Driver. In the Socket Driver it is necessary to use <c>EAcqStopFlags.KILL</c>!!</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_GetStreamInfo(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd,Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct@,System.UInt32@)">
            <summary>
            Get detailed information about a data stream
            </summary>
            <param name="DSHandle">Handle to a valid data stream object, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
            <param name="Cmd">The information type that is requested</param>
            <param name="Info">Reference to a structure where the information is stored.</param>
            <param name="Size">The size of the structure. The function sets the actual size of data stored into the structure.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_GetBufferID(System.IntPtr,System.UInt32,System.IntPtr@)">
            <summary>
            Get the buffer handle by index
            </summary>
            <param name="DSHandle">Handle to a valid data stream, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
            <param name="Index">Zero based index for the buffer.</param>
            <param name="BufferHandle">Variable in which the buffer handle is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_Close(System.IntPtr)">
             <summary>
             Close the data stream
             </summary>
             <example>
             <code>
             //==============================================================////
             // Terminate Stream Thread
             //==============================================================////
             Boolean TerminateStreamThread()
             {
               // Is the data stream opened?
               if (StreamHandle == IntPtr.Zero)
                 return false;
            
               // Reset the thread execution flag.
               w.EnableThread = false;
            
               // Signal the image thread to stop faster
               J_Event_ExitCondition(NewImageCondition);
            
               // Stop the image acquisition engine
               J_DataStream_StopAcquisition(StreamHandle, EAcqStopFlags.KILL);
                 
               // Wait for the thread to end
               StreamEvent.WaitOne();
            
               // UnPrepare Buffers (this removed the buffers from the acquisition engine and frees buffers)
               UnPrepareBuffer();
            
               // Close Stream
               if (StreamHandle != IntPtr.Zero)
               {
                 J_DataStream_Close(StreamHandle);
                 StreamHandle = IntPtr.Zero;
               }
             
               m_streamThread = null;
            
               return true;
             }
             </code>
             </example>
             <param name="DSHandle">Handle to a valid data stream, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RevokeBuffer(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_QueueBuffer(System.IntPtr,System.IntPtr)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_GetBufferInfo(System.IntPtr,System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd,Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct@,System.UInt32@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_GetParam(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd,Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct@,System.UInt32@)">
             <summary>
             Get parameters for the data stream.
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate how to get a stream channel parameter using J_DataStream_GetParam()
            
             public bool IsResendEnabled(void)
             {
               Jai_FactoryWrapper.EFactoryError retsta;  
               bool bCanResend = false;  
               Jai_FactoryWrapper.StreamParameterStruct StreamParameter = new Jai_FactoryWrapper.StreamParameterStruct();
               uint Size = sizeof(uint);
             
               retsta = Jai_FactoryWrapper.J_DataStream_GetParam(StreamHandle, Jai_FactoryWrapper.EDataStreamParamCmd.CanResend, ref StreamParameter, ref Size);
             
               if (StreamParameter.CanResend != 0)
                 bCanResend = true;
               else
                 bCanResend = false;
             
               bCanResend retsta;
             }
             </code>
             </example>
             <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStream(System.IntPtr,System.UInt32,System.IntPtr@)"/>
             <param name="DSHandle">Handle to a valid data stream object, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
             <param name="Cmd">The parameter type which is requested</param>
             <param name="StreamParameter">Reference to a buffer in which the information is stored.</param>
             <param name="Size">The size of the buffer. The function sets the actual size of data stored into the buffer.</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_SetParam(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd,Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct@,System.UInt32@)">
             <summary>
             Set parameters for the data stream.
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate how to set a stream channel parameter using J_DataStream_SetParam()
            
             public Jai_FactoryWrapper.EFactoryError EnableResend(bool EnablePacketResend)
             {
               Jai_FactoryWrapper.EFactoryError retsta;  
               Jai_FactoryWrapper.StreamParameterStruct StreamParameter = new Jai_FactoryWrapper.StreamParameterStruct();
               if (EnablePacketResend)
                 StreamParameter.CanResend = 1;
               else
                 StreamParameter.CanResend = 0;
             
               uint Size = sizeof(uint);
             
               retsta = Jai_FactoryWrapper.J_DataStream_SetParam(StreamHandle, Jai_FactoryWrapper.EDataStreamParamCmd.CanResend, ref StreamParameter, ref Size);
             
               return retsta;
             }
             </code>
             </example>
             <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStream(System.IntPtr,System.UInt32,System.IntPtr@)"/>
             <param name="DSHandle">Handle to a valid data stream object, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
             <param name="Cmd">The parameter type which is requested</param>
             <param name="StreamParameter">Reference to a buffer in which the information is stored.</param>
             <param name="Size">The size of the buffer. The function sets the actual size of data stored into the buffer.</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_GetData(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData@,System.UInt32@)">
            <summary>
            Retrieve the event data associated with the event.
            
            The data type returned by this function will depend on the event type. If the event is of type <c>EDeviceEventType.NEW_BUFFER</c> then this
            function will return the image buffer handle as described by the <c>DeviceEventData.NEW_BUFFER_BufferHandle</c> structure value.
            If the event is of type <c>EDeviceEventType.GEV_EVENT_CMD</c> then this function will return information about the GEV command as 
            described by the <c>DeviceEventData.GEV_EVENT_CMD_xxx</c> structure values.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <param name="EventHandle">Internal event handle obtained by the <c>J_Camera_RegisterEvent()</c> or <c>J_DataStream_RegisterEvent()</c> functions.</param>
            <param name="EventData">Reference to a <c>DeviceEventData</c> structure in which the information is stored.</param>
            <param name="Size">The size of the structure. The function sets the actual size of data stored into the buffer.</param>
            <returns><c>Jai_FactoryWrapper.EFactoryError</c>. If no events are available in the event queue <c>EFactoryError.NoData</c> will be returned.</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_GetInfo(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EEventInfoID,Jai_FactoryDotNET.Jai_FactoryWrapper.EventInfoData@,System.UInt32@)">
            <summary>
            Retrieve event information.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <param name="EventHandle">Internal event handle obtained by the <c>J_Camera_RegisterEvent()</c> or <c>J_DataStream_RegisterEvent()</c> functions.</param>
            <param name="EventInfoID">Event information type to retrieve</param>
            <param name="EventInfo">Reference to a EventInfoData structure in which the information is stored.</param>
            <param name="Size">The size of the EventInfoData structure. The function sets the actual size of data stored into the EventInfoData structure.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_Flush(System.IntPtr)">
            <summary>
            Flush all Event currently in the queue
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <param name="EventHandle">Internal event handle obtained by the <c>J_Camera_RegisterEvent()</c> or <c>J_DataStream_RegisterEvent()</c> functions.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_Close(System.IntPtr)">
            <summary>
            Close Event
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <param name="EventHandle">Internal event handle obtained by the <c>J_Camera_RegisterEvent()</c> or <c>J_DataStream_RegisterEvent()</c> functions.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)">
             <summary>
             Register an event for a device with the Transport Layer interface using Windows events
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate the basics used in getting connection status for a camera. It is not
             // intended to be used directly since it has no error handling built in but merely to show the API functions needed.
            
             class Work
             {
               public AutoResetEvent KillEvent = new AutoResetEvent(false);    // Event used to stop Thread faster
               public Boolean EnableThread = true;                             // Flag used to control thread run
               public CCamera camera = null;
            
               // Camera Connection thread
               public void StreamThread()
               {
                 UInt32 iSize;
                 int iWaitResult;
                 EFactoryError retsta;
            
                 DeviceEventData EventData = new DeviceEventData();
            
                 // Create event to be used by the Transport Layer to signal when the Camera Connection state changes
                 AutoResetEvent ConnectionEvent = new AutoResetEvent(false);
            
                 // Make a WaitHandle list
                 WaitHandle[] waitHandles = { ConnectionEvent, KillEvent };
            
                 IntPtr hDeviceEvent; // Buffer event handle
            
                 // Register the event with the Transport Layer
                 retsta = J_Camera_RegisterEvent(camera.CameraHandle, 
                                                 EDeviceEventType.CONNECTION, 
                                                 ConnectionEvent.SafeWaitHandle, 
                                                 out hDeviceEvent);
            
                 while (EnableThread)
                 {
                   // Wait for connection status event (or kill event)
                   iWaitResult = WaitHandle.WaitAny(waitHandles, 1000, false);
            
                   // Did we get a connection status event?
                   if (iWaitResult == 0)
                   {
                     // Get the data associated with the event
                     iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                     retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
             
                     if (retsta == EFactoryError.Success)
                     {
                       camera.CurrentConnectionStatus = EventData.CONNECTION_Status;
            
                       if (EnableThread)
                       {
                         if (camera != null)
                         camera.HandleConnection(camera.CurrentConnectionStatus);
                       }
                     }
                   }
                 }
            
                 // Unregister the Camera Connection event
                 retsta = J_Camera_UnRegisterEvent(camera.CameraHandle, EDeviceEventType.CONNECTION);
            
                 // Free the event object
                 if (hDeviceEvent != null)
                 {
                   J_Event_Close(hDeviceEvent);
                   hDeviceEvent = IntPtr.Zero;
                 }
               }
             }
             </code>
             </example>
             <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
             <param name="EventType">Event type to register</param>
             <param name="WaitHandle">Native OS handle to be used for signalling the event. This can be created as using <c>AutoResetEvent.SafeWaitHandle</c> </param>
             <param name="EventHandle">Variable in which the internal event handle is stored. This handle is used in <c>J_Event_GetData()</c> and <c>J_Event_GetInfo()</c> </param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,System.IntPtr,System.IntPtr@)">
             <summary>
             Register an event for a device with the Transport Layer interface using JAI SDK Conditions instead of events
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate the basics used in getting connection status for a camera. It is not
             // intended to be used directly since it has no error handling built in but merely to show the API functions needed.
            
             class ConnectionStatusWork
             {
               public IntPtr ConnectionCondition = IntPtr.Zero;
               public IntPtr CameraHandle = IntPtr.Zero;
               public Boolean EnableThread = true;
               public CCamera camera = null;
            
               public void ConnectionStatusThread()
               {
                 UInt32 iSize;
                 EFactoryError retsta;
                 ECondWaitResult WaitResult = ECondWaitResult.WaitError;
            
                 DeviceEventData EventData = new DeviceEventData();
            
                 if (ConnectionCondition == IntPtr.Zero)
                   retsta = J_Event_CreateCondition(ref ConnectionCondition);
            
                 IntPtr hDeviceEvent; // Buffer event handle
            
                 // Register the event with the Transport Layer
                 retsta = J_Camera_RegisterEvent(camera.CameraHandle, 
                                                 EDeviceEventType.CONNECTION, 
                                                 ConnectionCondition, 
                                                 out hDeviceEvent);
            
                 while (EnableThread)
                 {
                   // Wait for connection event
                   retsta = J_Event_WaitForCondition(ConnectionCondition, 1000, ref WaitResult);
            
                   if (retsta == EFactoryError.Success)
                   {
                     // Did we get a new buffer event?
                     if (WaitResult == ECondWaitResult.WaitSignal)
                     {
                       // Get the Buffer Handle from the event
                       iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                       retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
             
                       if (retsta == EFactoryError.Success)
                       {
                         if (EnableThread)
                         {
                           if (camera != null)
                             camera.HandleConnectionStatus(camera, EventData.CONNECTION_Status);
                         }
                       }
                     }
                     else
                     {
                       switch (WaitResult)
                       {
                         // Kill event
                         case ECondWaitResult.WaitExit:
                           break;
                         // Timeout
                         case ECondWaitResult.WaitTimeout:
                           break;
                         case ECondWaitResult.WaitError:
                           break;
            
                         // Unknown?
                         default:
                           break;
                       }
                     }
                   }
                 }
            
                 // Unregister connection event with Transport Layer
                 retsta = J_Camera_UnRegisterEvent(camera.CameraHandle, EDeviceEventType.CONNECTION);
            
                 // Free the event object
                 if (hDeviceEvent != null)
                 {
                   J_Event_Close(hDeviceEvent);
                   hDeviceEvent = IntPtr.Zero;
                 }
            
                 // Close the condition again
                 if (ConnectionCondition != IntPtr.Zero)
                   retsta = J_Event_CloseCondition(ConnectionCondition);
            
                 // Signal that we terminated the thread.
                 camera.ConnectionEvent.Set();
               }
             }
             </code>
             </example>
             <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
             <param name="EventType">Event type to register</param>
             <param name="ConditionHandle">Condition handle to be used for signalling the event. This can be created as using <c>J_Event_CreateCondition()</c> </param>
             <param name="EventHandle">Variable in which the internal event handle is stored. This handle is used in <c>J_Event_GetData()</c> and <c>J_Event_GetInfo()</c> </param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_UnRegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType)">
            <summary>
            Un-register an event with the Transport Layer interface
            </summary>
            <param name="CameraHandle">Handle to a valid camera object, obtained by <c>J_Camera_Open()</c> function.</param>
            <param name="EventType">Event type to un-register</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)">
             <summary>
             Register an event with the Transport Layer interface
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate the basics used in the image acquisition thread for a camera. It is not
             // intended to be used directly since it has no error handling built in but merely to show the API functions needed.
            
             class Work
             {
               public AutoResetEvent KillEvent = new AutoResetEvent(false); // Event used to stop Stream Thread faster
               public IntPtr DataStreamHandle = IntPtr.Zero;                // DataStream Handle
               public Boolean EnableThread = true;                          // Flag used to control thread run
               public CCamera camera = null;
            
               // Data stream thread
               public void StreamThread()
               {
                 UInt32 iSize;
                 bool FirstTime = true;
                 EFactoryError retsta;
            
                 // Create structure to be used for image display
                 ImageInfo ImageInfo = new ImageInfo();
                 BufferInfoStruct BufferInfo = new BufferInfoStruct();
            
                 int iWaitResult;
            
                 DeviceEventData EventData = new DeviceEventData();
            
                 // Create event to be used by acquisition engine to signal that a new image has been acquired
                 AutoResetEvent NewImageEvent = new AutoResetEvent(false);
            
                 // Make a WaitHandle list
                 WaitHandle[] waitHandles = { NewImageEvent, KillEvent };
            
                 IntPtr hDeviceEvent; // Buffer event handle
            
                 // Register the event with the acquisition engine
                 retsta = J_DataStream_RegisterEvent(DataStreamHandle, 
                                                     EDeviceEventType.NEW_BUFFER, 
                                                     NewImageEvent.SafeWaitHandle, 
                                                     out hDeviceEvent);
            
                 // Start image acquisition
                 retsta = J_DataStream_StartAcquisition(DataStreamHandle, EAcqStartFlags.NEXT_IMAGE, 0);
            
                 while (EnableThread)
                 {
                   // Wait for Buffer event (or kill event)
                   iWaitResult = WaitHandle.WaitAny(waitHandles, 1000, false);
            
                   // Did we get a new buffer event?
                   if (iWaitResult == 0)
                   {
                     // Get the Buffer Handle from the event
                     iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                     retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
            
                     if (retsta == EFactoryError.Success)
                     {
                       // Fill in structure for image display
                       // Get the pointer to the frame buffer.
                       iSize = (uint)Marshal.SizeOf(typeof(BufferInfoStruct));
                       retsta = J_DataStream_GetBufferInfo(DataStreamHandle, 
                                                           EventData.NEW_BUFFER_BufferHandle, 
                                                           EBufferInfoCmd.BASE, 
                                                           ref BufferInfo, 
                                                           ref iSize);
                       ImageInfo.ImageBuffer = BufferInfo.Base;
            
                       // Get Timestamp.
                       iSize = (uint)Marshal.SizeOf(typeof(BufferInfoStruct));
                       retsta = J_DataStream_GetBufferInfo(DataStreamHandle, 
                                                           EventData.NEW_BUFFER_BufferHandle, 
                                                           EBufferInfoCmd.TIMESTAMP, 
                                                           ref BufferInfo, 
                                                           ref iSize);
                       ImageInfo.TimeStamp = BufferInfo.TimeStamp;
            
                       // Get the effective data size.
                       iSize = (uint)Marshal.SizeOf(typeof(BufferInfoStruct));
                       retsta = J_DataStream_GetBufferInfo(DataStreamHandle, 
                                                           EventData.NEW_BUFFER_BufferHandle, 
                                                           EBufferInfoCmd.SIZE, 
                                                           ref BufferInfo, 
                                                           ref iSize);
                       ImageInfo.ImageSize = BufferInfo.Size;
            
                       // Get Pixel Format Type.
                       iSize = (uint)Marshal.SizeOf(typeof(BufferInfoStruct));
                       retsta = J_DataStream_GetBufferInfo(DataStreamHandle, 
                                                           EventData.NEW_BUFFER_BufferHandle, 
                                                           EBufferInfoCmd.PIXELTYPE, 
                                                           ref BufferInfo, 
                                                           ref iSize);
                       ImageInfo.PixelFormat = BufferInfo.PixelFormat;
            
                       // Get Frame Width.
                       iSize = (uint)Marshal.SizeOf(typeof(BufferInfoStruct));
                       retsta = J_DataStream_GetBufferInfo(DataStreamHandle, 
                                                           EventData.NEW_BUFFER_BufferHandle, 
                                                           EBufferInfoCmd.WIDTH, 
                                                           ref BufferInfo, 
                                                           ref iSize);
                       ImageInfo.SizeX = BufferInfo.Width;
            
                       // Get Frame Height.
                       iSize = (uint)Marshal.SizeOf(typeof(BufferInfoStruct));
                       retsta = J_DataStream_GetBufferInfo(DataStreamHandle, 
                                                           EventData.NEW_BUFFER_BufferHandle, 
                                                           JEBufferInfoCmd.HEIGHT, 
                                                           ref BufferInfo, 
                                                           ref iSize);
                       ImageInfo.SizeY = BufferInfo.Height;
            
                       if (EnableThread)
                       {
                         if (camera != null)
                           camera.HandleImage(ref ImageInfo);
                       }
             
                       // Queue This Buffer Again for reuse in acquisition engine
                       retsta = J_DataStream_QueueBuffer(DataStreamHandle, EventData.NEW_BUFFER_BufferHandle);
            
                       if (camera.NumFramesAwaitingDelivery > 0)
                         NewImageEvent.Set();
                     }
                   }
                 }
            
                 retsta = J_DataStream_FlushQueue(DataStreamHandle, EAcqQueueType.OUTPUT_DISCARD);
            
                 // Unregister new buffer event with acquisition engine
                 retsta = J_DataStream_UnRegisterEvent(DataStreamHandle, EDeviceEventType.NEW_BUFFER);
            
                 // Free the event object
                 if (hDeviceEvent != null)
                 {
                   retsta = J_Event_Close(hDeviceEvent);
                   hDeviceEvent = IntPtr.Zero;
                 }
            
                 // Signal that we terminated the thread.
                 camera.StreamEvent.Set();
               }
             }
             </code>
             </example>
             <param name="DSHandle">Handle to a valid data stream object, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
             <param name="EventType">Event type to register</param>
             <param name="WaitHandle">Native OS handle to be used for signalling the event. This can be created as using <c>AutoResetEvent.SafeWaitHandle</c> </param>
             <param name="EventHandle">Variable in which the internal event handle is stored. This handle is used in <c>J_Event_GetData()</c> and <c>J_Event_GetInfo()</c> </param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,System.IntPtr,System.IntPtr@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_UnRegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType)">
            <summary>
            Un-register an event with the Transport Layer interface
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_CreateDataStream(System.IntPtr,System.UInt32,System.IntPtr@)"/>
            <param name="DSHandle">Handle to a valid data stream object, obtained by <c>J_Camera_CreateDataStream()</c> function.</param>
            <param name="EventType">Event type to un-register</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_CreateCondition(System.IntPtr@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_SignalCondition(System.IntPtr)">
            <summary>
            Signal Condition object. <c>J_Event_WaitForCondition()</c> will return ECondWaitResult.WaitSignal if this is called.
            </summary>
            <param name="ConditionHandle">Internal Condition handle obtained by the <c>J_Event_CreateCondition()</c> function.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_ExitCondition(System.IntPtr)">
            <summary>
            Send an EXIT Signal to the Condition object. <c>J_Event_WaitForCondition()</c> will return ECondWaitResult.WaitExit if this is called.
            </summary>
            <param name="ConditionHandle">Internal Condition handle obtained by the <c>J_Event_CreateCondition()</c> function.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_ResetCondition(System.IntPtr)">
            <summary>
            Reset the Condition object state to its initial state.
            </summary>
            <param name="ConditionHandle">Internal Condition handle obtained by the <c>J_Event_CreateCondition()</c> function.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_WaitForCondition(System.IntPtr,System.UInt32,Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult@)">
             <summary>
             Wait for the Condition object to be signaled.
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate the basics used in getting connection status for a camera. It is not
             // intended to be used directly since it has no error handling built in but merely to show the API functions needed.
            
             class ConnectionStatusWork
             {
               public IntPtr ConnectionCondition = IntPtr.Zero;
               public IntPtr CameraHandle = IntPtr.Zero;
               public Boolean EnableThread = true;
               public CCamera camera = null;
            
               public void ConnectionStatusThread()
               {
                 UInt32 iSize;
                 EFactoryError retsta;
                 ECondWaitResult WaitResult = ECondWaitResult.WaitError;
            
                 DeviceEventData EventData = new DeviceEventData();
            
                 if (ConnectionCondition == IntPtr.Zero)
                   retsta = J_Event_CreateCondition(ref ConnectionCondition);
            
                 IntPtr hDeviceEvent; // Buffer event handle
            
                 // Register the event with the Transport Layer
                 retsta = J_Camera_RegisterEvent(camera.CameraHandle, 
                                                 EDeviceEventType.CONNECTION, 
                                                 ConnectionCondition, 
                                                 out hDeviceEvent);
            
                 while (EnableThread)
                 {
                   // Wait for connection event
                   retsta = J_Event_WaitForCondition(ConnectionCondition, 1000, ref WaitResult);
            
                   if (retsta == EFactoryError.Success)
                   {
                     // Did we get a Camera Connection event?
                     if (WaitResult == ECondWaitResult.WaitSignal)
                     {
                       // Get the Buffer Handle from the event
                       iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                       retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
             
                       if (retsta == EFactoryError.Success)
                       {
                         if (EnableThread)
                         {
                           if (camera != null)
                             camera.HandleConnectionStatus(camera, EventData.CONNECTION_Status);
                         }
                       }
                     }
                     else
                     {
                       switch (WaitResult)
                       {
                         // Kill event
                         case ECondWaitResult.WaitExit:
                           break;
                         // Timeout
                         case ECondWaitResult.WaitTimeout:
                           break;
                         case ECondWaitResult.WaitError:
                           break;
            
                         // Unknown?
                         default:
                           break;
                       }
                     }
                   }
                 }
            
                 // Unregister connection event with Transport Layer
                 retsta = J_Camera_UnRegisterEvent(camera.CameraHandle, EDeviceEventType.CONNECTION);
            
                 // Free the event object
                 if (hDeviceEvent != null)
                 {
                   retsta = J_Event_Close(hDeviceEvent);
                   hDeviceEvent = IntPtr.Zero;
                 }
            
                 // Close the condition again
                 if (ConnectionCondition != IntPtr.Zero)
                   retsta = J_Event_CloseCondition(ConnectionCondition);
            
                 // Signal that we terminated the thread.
                 camera.ConnectionEvent.Set();
               }
             }
             </code>
             </example>
             <param name="ConditionHandle">Internal Condition handle obtained by the <c>J_Event_CreateCondition()</c> function.</param>
             <param name="timeout">Timeout for the Wait operation. If timeout is set to 0 then it will wait forever</param>
             <param name="WaitResult">Result for the Wait operation. This can either be ECondWaitResult.WaitTimeout, ECondWaitResult.WaitSignal, ECondWaitResult.WaitExit or ECondWaitResult.WaitError</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_WaitForMultipleConditions(System.Int32,System.IntPtr[],System.UInt32,Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult@)">
             <summary>
             Wait for one of multiple Condition objects to be signaled.
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate the basics used in getting connection status for a camera. It is not
             // intended to be used directly since it has no error handling built in but merely to show the API functions needed.
            
             class ConnectionStatusWork
             {
               public IntPtr GevEventCondition = IntPtr.Zero;
               public IntPtr ConnectionCondition = IntPtr.Zero;
               public IntPtr[] ConditionList = new IntPtr[2];
               public IntPtr CameraHandle = IntPtr.Zero;
               public Boolean EnableThread = true;
               public CCamera camera = null;
            
               public void ConnectionStatusThread()
               {
                 UInt32 iSize;
                 EFactoryError retsta;
                 ECondWaitResult WaitResult = ECondWaitResult.WaitError;
            
                 DeviceEventData EventData = new DeviceEventData();
            
                 if (GevEventCondition == IntPtr.Zero)
                   retsta = J_Event_CreateCondition(ref GevEventCondition);
            
                 if (ConnectionCondition == IntPtr.Zero)
                   retsta = J_Event_CreateCondition(ref ConnectionCondition);
             
                 ConditionList[0] = GevEventCondition;
                 ConditionList[1] = ConnectionCondition;
            
                 IntPtr hGevEvent; // GigE Vision Event handle
            
                 // Register the event with the Transport Layer
                 retsta = J_Camera_RegisterEvent(camera.CameraHandle, 
                                                 EDeviceEventType.GEV_EVENT_CMD, 
                                                 GevEventCondition, 
                                                 out hGevEvent);
            
                 IntPtr hDeviceEvent; // Camera Connection handle
            
                 // Register the event with the Transport Layer
                 retsta = J_Camera_RegisterEvent(camera.CameraHandle, 
                                                 EDeviceEventType.CONNECTION, 
                                                 ConnectionCondition, 
                                                 out hDeviceEvent);
            
                 while (EnableThread)
                 {
                   // Wait for connection event
                   retsta = J_Event_WaitForMultipleConditions(2, ConditionList, 1000, ref WaitResult);
            
                   if (retsta == EFactoryError.Success)
                   {
                     // Did we get a GigE Vision event?
                     if (WaitResult == ECondWaitResult.WaitSignal)
                     {
                       // Get the Buffer Handle from the event
                       iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                       retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
             
                       if (retsta == EFactoryError.Success)
                       {
                         // Do something with the event
                         byte[] eventData = new byte[EventData.GEV_EVENT_CMD_EventDataLength];
                         Array.Copy(EventData.GEV_EVENT_CMD_EventData, eventData, EventData.GEV_EVENT_CMD_EventDataLength);
                         
                         HandleGEVEvent(EventData.GEV_EVENT_CMD_EventID, EventData.GEV_EVENT_CMD_StreamChannelIndex, EventData.GEV_EVENT_CMD_BlockID, EventData.GEV_EVENT_CMD_Timestamp, eventData);
                         ...
                       }
                     }
                     else
                     if (WaitResult == ECondWaitResult.WaitSignal1)
                     {
                       // Get the Buffer Handle from the event
                       iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                       retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
             
                       if (retsta == EFactoryError.Success)
                       {
                         // Do something with the event
                         HandleConnectionStatus(camera, EventData.CONNECTION_Status);
                         ...
                       }
                     }
                     else
                     {
                       switch (WaitResult)
                       {
                         // Kill event
                         case ECondWaitResult.WaitExit:
                         case ECondWaitResult.WaitExit1:
                           break;
                         // Timeout
                         case ECondWaitResult.WaitTimeout:
                           break;
                         case ECondWaitResult.WaitError:
                           break;
            
                         // Unknown?
                         default:
                           break;
                       }
                     }
                   }
                 }
            
                 // Unregister GigE Vision event with Transport Layer
                 retsta = J_Camera_UnRegisterEvent(camera.CameraHandle, EDeviceEventType.GEV_EVENT_CMD);
            
                 // Free the event object
                 if (hGevEvent != null)
                 {
                   retsta = J_Event_Close(hGevEvent);
                   hGevEvent = IntPtr.Zero;
                 }
            
                 // Close the condition again
                 if (GevEventCondition != IntPtr.Zero)
                   retsta = J_Event_CloseCondition(GevEventCondition);
            
                 // Unregister connection event with Transport Layer
                 retsta = J_Camera_UnRegisterEvent(camera.CameraHandle, EDeviceEventType.CONNECTION);
            
                 // Free the event object
                 if (hDeviceEvent != null)
                 {
                   retsta = J_Event_Close(hDeviceEvent);
                   hDeviceEvent = IntPtr.Zero;
                 }
            
                 // Close the condition again
                 if (ConnectionCondition != IntPtr.Zero)
                   retsta = J_Event_CloseCondition(ConnectionCondition);
               }
             }
             </code>
             </example>
             <param name="nCount">Number of condition handles to handle. This have to be between 1 and 10</param>
             <param name="ConditionHandles">Internal Condition handle obtained by the <c>J_Event_CreateCondition()</c> function.</param>
             <param name="timeout">Timeout for the Wait operation. If timeout is set to 0 then it will wait forever</param>
             <param name="WaitResult">Result for the Wait operation. This can either be ECondWaitResult.WaitTimeout, ECondWaitResult.WaitSignal, ECondWaitResult.WaitExit or ECondWaitResult.WaitError</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Event_CloseCondition(System.IntPtr)">
             <summary>
             Close the Condition object.
             </summary>
             <example>
             <code>
             // This small piece of code demonstrate the basics used in getting connection status for a camera. It is not
             // intended to be used directly since it has no error handling built in but merely to show the API functions needed.
            
             class ConnectionStatusWork
             {
               public IntPtr ConnectionCondition = IntPtr.Zero;
               public IntPtr CameraHandle = IntPtr.Zero;
               public Boolean EnableThread = true;
               public CCamera camera = null;
            
               public void ConnectionStatusThread()
               {
                 UInt32 iSize;
                 EFactoryError retsta;
                 ECondWaitResult WaitResult = ECondWaitResult.WaitError;
            
                 DeviceEventData EventData = new DeviceEventData();
            
                 if (ConnectionCondition == IntPtr.Zero)
                   retsta = J_Event_CreateCondition(ref ConnectionCondition);
            
                 IntPtr hDeviceEvent; // Buffer event handle
            
                 // Register the event with the Transport Layer
                 retsta = J_Camera_RegisterEvent(camera.CameraHandle, 
                                                 EDeviceEventType.CONNECTION, 
                                                 ConnectionCondition, 
                                                 out hDeviceEvent);
            
                 while (EnableThread)
                 {
                   // Wait for connection event
                   retsta = J_Event_WaitForCondition(ConnectionCondition, 1000, ref WaitResult);
            
                   if (retsta == EFactoryError.Success)
                   {
                     // Did we get a new buffer event?
                     if (WaitResult == ECondWaitResult.WaitSignal)
                     {
                       // Get the Buffer Handle from the event
                       iSize = (uint)Marshal.SizeOf(typeof(DeviceEventData));
                       retsta = J_Event_GetData(hDeviceEvent, out EventData, ref iSize);
             
                       if (retsta == EFactoryError.Success)
                       {
                         if (EnableThread)
                         {
                           if (camera != null)
                             camera.HandleConnectionStatus(camera, EventData.CONNECTION_Status);
                         }
                       }
                     }
                     else
                     {
                       switch (WaitResult)
                       {
                         // Kill event
                         case ECondWaitResult.WaitExit:
                           break;
                         // Timeout
                         case ECondWaitResult.WaitTimeout:
                           break;
                         case ECondWaitResult.WaitError:
                           break;
            
                         // Unknown?
                         default:
                           break;
                       }
                     }
                   }
                 }
            
                 // Unregister connection event with Transport Layer
                 retsta = J_Camera_UnRegisterEvent(camera.CameraHandle, EDeviceEventType.CONNECTION);
            
                 // Free the event object
                 if (hDeviceEvent != null)
                 {
                   retsta = J_Event_Close(hDeviceEvent);
                   hDeviceEvent = IntPtr.Zero;
                 }
            
                 // Close the condition again
                 if (ConnectionCondition != IntPtr.Zero)
                   retsta = J_Event_CloseCondition(ConnectionCondition);
            
                 // Signal that we terminated the thread.
                 camera.ConnectionEvent.Set();
               }
             }
             </code>
             </example>
             <param name="ConditionHandle">Internal Condition handle obtained by the <c>J_Event_CreateCondition()</c> function.</param>
             <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetAccessMode(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode@)">
            <summary>
            Get the access mode for a GenICam node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="AccessMode">Access mode of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetName(System.IntPtr,System.Text.StringBuilder,System.UInt32@,System.UInt32)">
            <summary>
            Get the GenICam name for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Buffer">StringBuilder to put the node name</param>
            <param name="Size">Capacity of the StringBuilder. The length of the name will be returned</param>
            <param name="FullQualified">If this value is not 0 then the full qualified name will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetNameSpace(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNameSpace@)">
            <summary>
            Get the namespace for a GenICam node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="NameSpace">Reference to variable where the Namespace of the node will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetVisibility(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility@)">
            <summary>
            Get the recommended visibility for a GenICam node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Visibility">Recommended visibility of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_Invalidate(System.IntPtr)">
            <summary>
            Invalidate the node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetIsCachable(System.IntPtr,System.UInt32@)">
            <summary>
            Get if the GenICam node is cachable. If the node is not cachable it will need to be read periodically. 
            The recommended polling time can be read using <c>J_Node_GetPollingTime()</c>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="IsCachable">Is the node cachable</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetCachingMode(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfCachingMode@)">
            <summary>
            Get the caching mode for a GenICam node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="CachingMode">Caching mode of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetPollingTime(System.IntPtr,System.Int64@)">
            <summary>
            Get the recommended polling time for the GenICam node. This is only necessary if the node is not cachable.
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="PollingTime">Recommended polling time (in milliseconds) of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetToolTip(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the tooltip for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="ToolTip">StringBuilder to put the tooltip</param>
            <param name="Size">Capacity of the StringBuilder. The length of the tooltip will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetDescription(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the description for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Description">StringBuilder to put the description</param>
            <param name="Size">Capacity of the StringBuilder. The length of the description will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetDisplayName(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the display name for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="DisplayName">StringBuilder to put the display name</param>
            <param name="Size">Capacity of the StringBuilder. The length of the display name will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetEventID(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the Event ID string for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="EventID">StringBuilder to put the Event ID</param>
            <param name="Size">Capacity of the StringBuilder. The length of the Event ID will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetIsStreamable(System.IntPtr,System.UInt32@)">
            <summary>
            Get if the GenICam node is streamable.
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="IsStreamable">Is the node streamable</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetNumOfProperties(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of properties on the node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="NumOfProperties">The number of properties</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetPropertyNameByIndex(System.IntPtr,System.UInt32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the name of the property by index
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Index">The index of the property</param>
            <param name="PropertyName">StringBuilder to put the property name</param>
            <param name="Size">Capacity of the StringBuilder. The length of the property name will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetPropertyByName(System.IntPtr,System.String,System.Text.StringBuilder,System.UInt32@,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the property value and attribute string by property name
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="PropertyName">Name of the property retrieved using <c>J_Node_GetPropertyNameByIndex()</c> </param>
            <param name="ValueStr">StringBuilder to put the value string</param>
            <param name="SizeValueStr">Capacity of the StringBuilder. The length of the value string will be returned</param>
            <param name="AttributeStr">StringBuilder to put the attribute string</param>
            <param name="SizeAttributeStr">Capacity of the StringBuilder. The length of the attribute string will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_ImposeAccessMode(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode)">
            <summary>
            Override the current access mode for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="AccessMode">The new imposed access mode</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_ImposeVisibility(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility)">
            <summary>
            Override the current recommended visibility for a node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Visibility">The new recommended visibility mode</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetAlias(System.IntPtr,System.IntPtr@)">
            <summary>
            Retrieves a node which describes the same feature in a different way
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="AliasNodeHandle">Handle to a node that describes the same feature differently</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_RegisterCallback(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.NodeChangeDelegate)">
            <summary>
            Register a delegate for a specific node. The delegate will be called when the node changes state or value
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="NodeChangeDelegateFunction">A delegate of type <c>NodeChangeDelegate</c> </param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetType(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType@)">
            <summary>
            Get the GenICam node type of the node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="NodeType">The type of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetIsSelector(System.IntPtr,System.UInt32@)">
            <summary>
            Get if the GenICam node is a Selector.
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="IsSelector">Is the node a Selector</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetNumOfSelectedFeatures(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of Selected Features on the Selector node
            
            Use <c>J_NodeGetIsSelector()</c> to determine if the node is a Selector node or not
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam Selector node</param>
            <param name="NumOfSelectedFeatures">The number of features that are selected by this Selector</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetSelectedFeatureByIndex(System.IntPtr,System.UInt32,System.IntPtr@)">
            <summary>
            Get the selected feature node by index
            
            Use <c>J_NodeGetIsSelector()</c> to determine if the node is a Selector node or not
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam Selector node</param>
            <param name="Index">Index of the Selected feature node entry</param>
            <param name="SelectedNodeHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetNumOfSelectingFeatures(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of Selecting Features on the Selector node
            
            Use <c>J_NodeGetIsSelector()</c> to determine if the node is a Selector node or not
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam Selector node</param>
            <param name="NumOfSelectingFeatures">The number of features that are selecting this Selector</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetSelectingFeatureByIndex(System.IntPtr,System.UInt32,System.IntPtr@)">
            <summary>
            Get the selecting feature node by index
            
            Use <c>J_NodeGetIsSelector()</c> to determine if the node is a Selector node or not
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam Selector node</param>
            <param name="Index">Index of the Selecting feature node entry</param>
            <param name="SelectingNodeHandle"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetRepresentation(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation@)">
            <summary>
            Get the Representation specified for the node
            </summary>
            <remarks>
            The node type has to be <c>IInteger</c> or <c>IFloat</c>.
            </remarks>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Representation">Reference to the variable in which the Representation is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetUnit(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the Unit string specified for the node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Unit">StringBuilder to put the Unit string</param>
            <param name="Size">Capacity of the StringBuilder. The length of the Unit string will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetDocuURL(System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the Documentation URL string specified for the node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="DocuURL">StringBuilder to put the Documentation URL string</param>
            <param name="Size">Capacity of the StringBuilder. The length of the Documentation URL string will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetIsDeprecated(System.IntPtr,System.UInt32@)">
            <summary>
            Get if the GenICam node is Deprecated.
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="IsDeprecated">Nonzero if the node is deprecated</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetMinInt64(System.IntPtr,System.Int64@)">
            <summary>
            Get minimum value allowed for the node.
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Min">Reference to a <c>Int64</c> variable to receive the minimum value for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetMaxInt64(System.IntPtr,System.Int64@)">
            <summary>
            Get maximum value allowed for the node
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Max">Reference to a <c>Int64</c> variable to receive the maximum value for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetInc(System.IntPtr,System.Int64@)">
            <summary>
            Get the increment value for the node.
            
            The increment determines together with the minimum- and maximum value which values are legal for the node.
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Inc">Reference to a <c>Int64</c> variable to receive the increment value for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_SetValueInt64(System.IntPtr,System.Boolean,System.Int64)">
            <summary>
            Set the node value
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Verify">Verify that the value is set</param>
            <param name="Value">The new value to be set in the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetValueInt64(System.IntPtr,System.Boolean,System.Int64@)">
            <summary>
            Get the node value
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IInteger</c></description></item>
            <item><description><c>EConfNodeType.IMaskedIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntReg</c></description></item>
            <item><description><c>EConfNodeType.IIntSwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IIntKey</c></description></item>
            <item><description><c>EConfNodeType.IIntConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Verify">Verify the value</param>
            <param name="Value">Reference to a <c>Int64</c> variable to receive the value of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetFloatAlias(System.IntPtr,System.IntPtr@)">
            <summary>
            Get the <c>IFloat</c> Alias node from the <c>IInteger</c> node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="FloatNodeHandle">Reference to a <c>NODE_HANDLE</c> variable to receive the handle of the Float Alias node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetMinDouble(System.IntPtr,System.Double@)">
            <summary>
            Get minimum value allowed for the node.
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IFloat</c></description></item>
            <item><description><c>EConfNodeType.IFloatReg</c></description></item>
            <item><description><c>EConfNodeType.ISwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Min">Reference to a <c>double</c> variable to receive the minimum value for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetMaxDouble(System.IntPtr,System.Double@)">
            <summary>
            Get minimum value allowed for the node.
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IFloat</c></description></item>
            <item><description><c>EConfNodeType.IFloatReg</c></description></item>
            <item><description><c>EConfNodeType.ISwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Max">Reference to a <c>double</c> variable to receive the maximum value for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_SetValueDouble(System.IntPtr,System.Boolean,System.Double)">
            <summary>
            Set node value
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IFloat</c></description></item>
            <item><description><c>EConfNodeType.IFloatReg</c></description></item>
            <item><description><c>EConfNodeType.ISwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Verify">Verify that the value is set</param>
            <param name="Value">The new value to be set in the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetValueDouble(System.IntPtr,System.Boolean,System.Double@)">
            <summary>
            Get the node value
            
            The node type has to be one of the following node types:
            <list type="table">
            <item><description><c>EConfNodeType.IFloat</c></description></item>
            <item><description><c>EConfNodeType.IFloatReg</c></description></item>
            <item><description><c>EConfNodeType.ISwissKnife</c></description></item>
            <item><description><c>EConfNodeType.IConverter</c></description></item>
            </list>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Verify">Verify the value</param>
            <param name="Value">Reference to a <c>double</c> variable to receive the value of the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetDisplayNotation(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDisplayNotation@)">
            <summary>
            Get the Display Notation specified for the <c>IFloat</c> node
            </summary>
            <param name="NodeHandle">A valid handle to a <c>IFloat</c> GenICam node</param>
            <param name="Value">Reference to a <c>EDisplayNotation</c> variable to receive the Display Notation for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetDisplayPrecision(System.IntPtr,System.Int64@)">
            <summary>
            Get the Display Precision specified for the IFloat node
            </summary>
            <param name="NodeHandle">A valid handle to a <c>IFloat</c> GenICam node</param>
            <param name="Value">Reference to a <c>UInt64</c> variable to receive the Display Precision for the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetFloatHasInc(System.IntPtr,System.UInt32@)">
            <summary>
            Inquire if the <c>IFloat</c> node has got an Increment defined
            </summary>
            <param name="NodeHandle">A valid handle to a <c>IFloat</c> GenICam node</param>
            <param name="Value">Reference to a <c>UInt32</c> variable. The value will be non-zero if the <c>IFloat</c> node has got an Increment</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetFloatInc(System.IntPtr,System.Double@)">
            <summary>
            Get the constant increment value as double type from the <c>IFloat</c> node
            </summary>
            <param name="NodeHandle">A valid handle to a <c>IFloat</c> GenICam node</param>
            <param name="Value">Reference to a <c>double</c> variable where the constant increment will be placed</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetIntAlias(System.IntPtr,System.IntPtr@)">
            <summary>
            Get the <c>IInteger</c> Alias node from the <c>IFloat</c> node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="IntegerNodeHandle">Reference to a <c>NODE_HANDLE</c> variable to receive the handle of the Integer Alias node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetEnumAlias(System.IntPtr,System.IntPtr@)">
            <summary>
            Get the <c>IEnumeration</c> Alias node from the <c>IFloat</c> node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="EnumNodeHandle">Reference to a <c>NODE_HANDLE</c> variable to receive the handle of the Enumeration Alias node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetNumOfEnumEntries(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of enumeration entries on a <c>EConfNodeType.IEnumeration</c> node
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="NumOfEnumEntries">Reference to a <c>UInt32</c> variable that will receive the number of enumeration entries</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetEnumEntryByIndex(System.IntPtr,System.UInt32,System.IntPtr@)">
            <summary>
            Get the enumeration entry on a <c>EConfNodeType.IEnumeration</c> node. The node type returned will be <c>EConfNodeType.IEnumEntry</c>
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Index">Index of the enumeration entry</param>
            <param name="EnumNodeHandle">Handle to a <c>EConfNodeType.IEnumEntry</c> node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetEnumEntryValue(System.IntPtr,System.Int64@)">
            <summary>
            Get the integer value of a <c>EConfNodeType.IEnumEntry</c> node
            </summary>
            <param name="EnumNodeHandle">A valid handle to a <c>EConfNodeType.IEnumEntry</c> GenICam node</param>
            <param name="Value">Reference to a <c>Int32</c> variable that will receive the integer value of the <c>EConfNodeType.IEnumEntry</c> node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_ExecuteCommand(System.IntPtr)">
            <summary>
            Execute the GenICam command
            </summary>
            <param name="NodeHandle">A valid handle to a <c>EConfNodeType.ICommand</c> GenICam node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetCommandIsDone(System.IntPtr,System.UInt32@)">
            <summary>
            Read if the GenICam command has been executed
            </summary>
            <param name="NodeHandle">A valid handle to a <c>EConfNodeType.ICommand</c> GenICam node</param>
            <param name="IsDone">Is the command executed</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_SetValueString(System.IntPtr,System.Boolean,System.String)">
            <summary>
            Set node value as a String
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the value can be set
            The node type can be any type. The value will automatically be converted internally in the factory
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Verify">Verify that the value is set</param>
            <param name="ValueStr">The new value to be set in the node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetValueString(System.IntPtr,System.Boolean,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get node value as a String
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the value can be read
            The node type can be any type. The value will automatically be converted internally in the factory
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="Verify">Verify the value</param>
            <param name="ValueStr">StringBuilder to place the current value of the node</param>
            <param name="SizeValueStr">Capacity of the StringBuilder. The length of the value string will be returned</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_SetValueRegister(System.IntPtr,System.IntPtr,System.UInt64)">
            <summary>
            Writes register values to nodes of type EConfNodeType.IRegister, IIntReg, IStringReg or IFloatReg
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the value can be set
            The node type has to be either EConfNodeType.IRegister, EConfNodeType.IIntReg, EConfNodeType.IStringReg or EConfNodeType.IFloatReg. The value will automatically be converted internally in the factory
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="pBuffer">Pointer to the data to write to the register</param>
            <param name="Length">Length of the data to write to the register</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetValueRegister(System.IntPtr,System.IntPtr,System.UInt64)">
            <summary>
            Read register values of nodes of type EConfNodeType.IRegister, IIntReg, IStringReg or IFloatReg
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the value can be read
            The node type has to be either EConfNodeType.IRegister, EConfNodeType.IIntReg, EConfNodeType.IStringReg or EConfNodeType.IFloatReg. The value will automatically be converted internally in the factory
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="pBuffer">Pointer to a buffer where to put the data read from the register</param>
            <param name="Length">Capacity of the buffer</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetRegisterLength(System.IntPtr,System.UInt64@)">
            <summary>
            Get the length of a EConfNodeType.IRegister, IIntReg, IStringReg and IFloatReg node
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the length can be read
            The node type has to be either EConfNodeType.IRegister, EConfNodeType.IIntReg, EConfNodeType.IStringReg or EConfNodeType.IFloatReg. The value will automatically be converted internally in the factory
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="pLength">Reference to a <c>UInt64</c> variable to receive the length for the register node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_GetRegisterAddress(System.IntPtr,System.UInt64@)">
            <summary>
            Get the address of a EConfNodeType.IRegister, IIntReg, IStringReg and IFloatReg node
            
            The camera needs to be opened using <c>J_Camera_Open()</c> before the length can be read
            The node type has to be either EConfNodeType.IRegister, EConfNodeType.IIntReg, EConfNodeType.IStringReg or EConfNodeType.IFloatReg. The value will automatically be converted internally in the factory
            </summary>
            <param name="NodeHandle">A valid handle to a GenICam node</param>
            <param name="pAddress">Reference to a <c>UInt64</c> variable to receive the address for the register node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.GetPixelTypeColorInfo(Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType)">
            <summary>
            Get Color Information based on Pixel type
            </summary>
            <param name="pixelType">Pixel Type enumeration value</param>
            <returns>Jai_FactoryWrapper.EPixelTypeColorInfo</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.GetPixelTypeMemorySize(Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType)">
            <summary>
            Get memory size occupied by each pixel based on Pixel type
            </summary>
            <param name="pixelType">Pixel Type enumeration value</param>
            <returns>Number of bytes per pixel</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenViewWindow(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE@,System.IntPtr@)">
             <summary>
             Open image view window
             
             A window of size MaxSize is created for the client area. When the images are displayed using <c>J_ImageShowImage()</c> the view window will automatically be resized.
             </summary>
             <example>
             <code>
             // C# Sample that opens a live view window and starts acquisition
             ...
             Jai_FactoryWrapper.POINT pnt = new Jai_FactoryWrapper.POINT(10, 10);
            
             Int32 Width = Convert.ToInt32(GetValue("Width"));
             Int32 Height = Convert.ToInt32(GetValue("Height"));
             SIZE maxSize = new SIZE(Width, Height);
            
             // Open the live view
             EFactoryError error = EFactoryError.Success;
            
             error = J_Image_OpenViewWindow("Live view!", ref pnt, ref maxSize, out WindowHandle);
             if (error == EFactoryError.Success)
             {
               error = J_Image_OpenStreamLight(CameraHandle, 0, out StreamHandle);
               if (error == EFactoryError.Success)
               {
                 IntPtr nodeHandle;
            
                 error = J_Camera_GetNodeByName(CameraHandle, "AcquisitionStart", out nodeHandle);
            
                 if (error == EFactoryError.Success)
                   error = J_Node_ExecuteCommand(nodeHandle);
               }
             }
             </code>
             </example>
             <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_GetNodeByName(System.IntPtr,System.String,System.IntPtr@)"/>
             <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Node_ExecuteCommand(System.IntPtr)"/>
             <seealso cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError"/>
             <param name="WindowName">Name to be displayed in the view window caption</param>
             <param name="Point">Point of the upper left corner of the view window</param>
             <param name="MaxSize">Maximum size of the view window</param>
             <param name="WindowHandle">The handle of the created window (window object) is returned</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory </returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenViewWindowEx(Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWWindowType,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.RECT@,Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE@,System.IntPtr,System.IntPtr@)">
            <summary>
            Open image view window
            
            A window of size MaxSize is created for the client area. When the images are displayed using <c>J_ImageShowImage()</c> the view window will automatically be resized.
            </summary>
            <param name="WindowType">Type of window to be displayed</param>
            <param name="WindowName">Name to be displayed in the view window caption</param>
            <param name="FrameRect">The view window frame location on the screen</param>
            <param name="MaxSize">Maximum size of the view window</param>
            <param name="hParent">Windows handle to the parent window</param>
            <param name="WindowHandle">The handle of the created window (window object) is returned.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_CloseViewWindow(System.IntPtr)">
            <summary>
            Close view window previously opened with <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>
            </summary>
            <param name="WindowHandle">Handle that <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c> returned.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ShowImage(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Display an image in a view window.
            
            This function automatically converts the RAW image specified with <c>AqImageInfo</c> into DIB, and display it in the view window in the window of handle <c>WindowHandle</c> created with <c>J_Image_OpenViewWindow()</c>.
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="AqImageInfo">ImageInfo structure with information on RAW image.</param>
            <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ShowImage(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Display an image in a view window using a specific Bayer Color Interpolation algorithm.
            
            This function automatically converts the RAW image specified with <c>AqImageInfo</c> into DIB, and display it in the view window in the window of handle <c>WindowHandle</c> created with <c>J_Image_OpenViewWindow()</c>.
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="AqImageInfo">ImageInfo structure with information on RAW image.</param>
            <param name="BayerAlgorithm">Color interpolation algorithm.</param>
            <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetImageOffset(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,System.Int32)">
            <summary>
            Set image offset and zoom ratio
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="Offset">POINT structure pointer with the horizontal and vertical offset (number of pixels).</param>
            <param name="ZoomRatio">Zoom ratio: 100=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetImageOffsetEx(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,System.Double,System.Double)">
            <summary>
            Set image offset and zoom ratio (individually in both X and Y direction).
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="Offset">POINT structure pointer with the horizontal and vertical offset (number of pixels).</param>
            <param name="ZoomRatioX">Zoom ratio in X-direction: 100.0=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.</param>
            <param name="ZoomRatioY">Zoom ratio in Y-direction: 100.0=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetImageOffsetEx(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,System.Double@,System.Double@)">
            <summary>
            Get image offset and zoom ratio (individually in both X and Y direction).
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="Offset">POINT structure pointer with the horizontal and vertical offset (number of pixels).</param>
            <param name="ZoomRatioX">Zoom ratio in X-direction: 100.0=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.</param>
            <param name="ZoomRatioY">Zoom ratio in Y-direction: 100.0=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_MoveViewWindow(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@)">
            <summary>
            Move view window
            
            Moves the view window to the absolute position specified by <c>Point</c>
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="Point">Upper left position of the view window.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ResizeChildWindow(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.RECT@)">
            <summary>
            Resize child(view) window. Resize the child view window to new rectangle specified by <c>RECT</c>.
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="Rect">Relative rectangular coordinates from parent window.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetViewWindowRect(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.RECT@)">
            <summary>
            Get rectangular coordinates of the client area of the view window
            
            The current position and size of the client area of the view window is read into a <c>RECT</c> structure.
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c>.</param>
            <param name="Rect">Current view window child area coordinates.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetFrameWindowRect(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.RECT@)">
            <summary>
            Get position and size of the view window including the windows frame
            
            The current position and size of the frame of the view window is read into a <c>RECT</c> structure.
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c> </param>
            <param name="Rect">Current view window frame coordinates.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetViewWindowTitle(System.IntPtr,System.String)">
            <summary>
            Set the title of view window
            
            Modify the caption text of the view window
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c> </param>
            <param name="WindowTitle">String that will be displayed in title bar</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetViewWindowOption(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType,Jai_FactoryDotNET.Jai_FactoryWrapper.IVWOptionValue@)">
             <summary>
             Set the value for a View Window option.
             
             Modify of the options for the view window
             </summary>
             <example>
             <code>
             // C# Sample that show how to set a View Window option
             ...
             Jai_FactoryWrapper.POINT pnt = new Jai_FactoryWrapper.POINT(10, 10);
            
             Int32 Width = Convert.ToInt32(GetValue("Width"));
             Int32 Height = Convert.ToInt32(GetValue("Height"));
             SIZE maxSize = new SIZE(Width, Height);
             IVWOptionValue OptionValue;
            
             // Open the live view
             EFactoryError error = EFactoryError.Success;
            
             error = J_Image_OpenViewWindow("Live view!", ref pnt, ref maxSize, out WindowHandle);
             if (error == EFactoryError.Success)
             {
               // Set the View Window option so that Mouse cursor zoom will be enabled
               OptionValue.BooleanValue = true;
               error = J_Image_SetViewWindowOption(WindowHandle, EIVWOptionType.MouseZoom, ref OptionValue);
               if (error == EFactoryError.Success)
               {
                 error = J_Image_OpenStreamLight(CameraHandle, 0, out StreamHandle);
                 if (error == EFactoryError.Success)
                 {
                   IntPtr nodeHandle;
            
                   error = J_Camera_GetNodeByName(CameraHandle, "AcquisitionStart", out nodeHandle);
            
                   if (error == EFactoryError.Success)
                     error = J_Node_ExecuteCommand(nodeHandle);
                 }
               }
             }
             </code>
             </example>
             <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c> </param>
             <param name="Option">Option type to set</param>
             <param name="OptionValue">Reference to the value to assign to the option</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetViewWindowOption(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType,Jai_FactoryDotNET.Jai_FactoryWrapper.IVWOptionValue@)">
            <summary>
            Get the current View Window option value
            
            Read the value of the options for the view window
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c> </param>
            <param name="Option">Option type to get</param>
            <param name="OptionValue">Reference to the value to be assigned with the current value for the option</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetViewWindowCallback(System.IntPtr,System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageViewWindowCallBack)">
            <summary>
            
            </summary>
            <param name="WindowHandle">Handle to a view window previously opened using <c>J_Image_OpenViewWindow()</c> or <c>J_Image_OpenViewWindowEx()</c> </param>
            <param name="CBObject">Pointer to a callback class object that contains a dynamic callback function</param>
            <param name="CallbackDelegate">Pointer to a static or dynamic callback delegate</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenStream(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32,System.UInt32)">
            <summary>
            Open image stream channel
            </summary>
            <param name="CameraHandle">Handle to the camera</param>
            <param name="Channel">Stream channel index. This index is zero-based</param>
            <param name="CBObject">Pointer to a callback class object that contains a dynamic callback function</param>
            <param name="CallbackDelegate">Pointer to a static or dynamic callback delegate</param>
            <param name="StreamHandle">The handle of the created stream channel is returned.</param>
            <param name="BufferSize">Buffersize to be allocated per image</param>
            <param name="McIP">Multicast IP address</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenStreamLight(System.IntPtr,System.UInt32,System.IntPtr@)">
             <summary>
             Open image stream channel and let the factory automatically create all callback delegates and automatically display live images
             
             This is the easiest way to create a view window that will display live video from the cameras. After opening the stream channel the acquisition has to be started
             using the standard GenICam command <c>AcquisitionStart</c>.
             </summary>
             <example>
             <code>
             // C# Sample that opens a live view window and starts acquisition
             ...
             Jai_FactoryWrapper.POINT pnt = new Jai_FactoryWrapper.POINT(10, 10);
            
             Int32 Width = Convert.ToInt32(GetValue("Width"));
             Int32 Height = Convert.ToInt32(GetValue("Height"));
             SIZE maxSize = new SIZE(Width, Height);
            
             // Open the live view
             EFactoryError error = EFactoryError.Success;
            
             error = J_Image_OpenViewWindow("Live view!", ref pnt, ref maxSize, out WindowHandle);
             if (error == EFactoryError.Success)
             {
               error = J_Image_OpenStreamLight(CameraHandle, 0, out StreamHandle);
               if (error == EFactoryError.Success)
               {
                 IntPtr nodeHandle;
            
                 error = J_Camera_GetNodeByName(CameraHandle, "AcquisitionStart", out nodeHandle);
            
                 if (error == EFactoryError.Success)
                   error = J_Node_ExecuteCommand(nodeHandle);
               }
             }
             </code>
             </example>
             <param name="CameraHandle">Handle to the camera</param>
             <param name="Channel">Stream channel index. This index is zero-based</param>
             <param name="StreamHandle">The handle of the created stream channel is returned.</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_CloseStream(System.IntPtr)">
            <summary>
            Close a stream channel that has previously been opened using <c>J_Image_OpenStream()</c> or <c>J_Image_OpenStreamLight()</c>.
            </summary>
            <param name="StreamHandle">Handle to the stream channel</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetStreamInfo(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd,Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct@,System.UInt32@)">
            <summary>
            Get detailed information about the underlying data stream via stream handle
            </summary>
            <param name="StreamHandle">Handle to a valid stream channel, obtained by <c>J_Image_OpenStream()</c> function or <c>J_Image_OpenStreamLight()</c>.</param>
            <param name="Cmd">The information type that is requested</param>
            <param name="Info">Reference to a structure where the information is stored.</param>
            <param name="Size">The size of the structure. The function sets the actual size of data stored into the structure.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetStreamHandle(System.IntPtr,System.IntPtr@)">
            <summary>
            Get DataStream handle from internal image stream handle
            </summary>
            <param name="StreamHandle">Handle to a valid stream channel, obtained by <c>J_Image_OpenStream()</c> function or <c>J_Image_OpenStreamLight()</c>.</param>
            <param name="DSHandle">The DataStream handle requested</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FromRawToDIB(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Convert image from RAW to DIB
            
            Convert the RAW image specified with <c>AqImageInfo</c> into 32-bit aRGB, and store it in the area specified with BufferInfo.
            </summary>
            <param name="AqImageInfo">Pointer of ImageInfo structure with information on RAW data.</param>
            <param name="BufferInfo">Pointer of ImageInfo structure in which the converted image is written.</param>
            <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FromRawToDIB(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Convert image from RAW to DIB
            
            Convert the RAW image specified with <c>AqImageInfo</c> into 32-bit aRGB, and store it in the area specified with BufferInfo.
            This function makes it possible to specify which Bayer Color Interpolation algorithm to be used.
            </summary>
            <remarks>
            If the <c>BayerFast</c> or the <c>BayerFastMultiprocessor</c> algorithms are used then the output buffer will 
            only have the half vertical and horizontal resolution of the input image!
            </remarks>
            <param name="AqImageInfo">Pointer of ImageInfo structure with information on RAW data.</param>
            <param name="BufferInfo">Pointer of ImageInfo structure in which the converted image is written.</param>
            <param name="BayerAlgorithm">Color interpolation algorithm.</param>
            <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FromRawToImage(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.UInt32,System.UInt32,System.UInt32)">
             <summary>
             Convert from RAW to an image that can be saved or modified
             
             Convert the RAW image specified with AqImageInfo by the following rule, and store it in the area specified by BufferInfo.\n\n
             PixelFormat information for the converted image is returned in the BufferInfo structure:
             
             <TABLE>
             <TR><TD>AqImageInfo PixelFormat</TD><TD>BufferInfo PixelFormat</TD></TR>
             <TR><TD>8bpp Grayscale</TD><TD>8bpp Grayscale</TD></TR>
             <TR><TD>10-16bpp Grayscale</TD><TD>16bpp Grayscale (Shifted to MSB)</TD></TR>
             <TR><TD>24bpp RGB</TD><TD>24bpp BGR</TD></TR>
             <TR><TD>30bpp RGB</TD><TD>48bpp BGR (Shifted to MSB)</TD></TR>
             <TR><TD>8bpp Bayer</TD><TD>24bpp BGR</TD></TR>
             <TR><TD>10-12bpp Bayer</TD><TD>48bpp BGR (Shifted to MSB)</TD></TR>
             </TABLE>
             </summary>
             <example>
             <code>
             // C# Sample that converts a raw image and saved the result to a file
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvertedImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Save the image to disk in TIFF format
                 error = J_Image_SaveFile(ref ConvertedImageInfo, FileName);
               }
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="AqImageInfo">Reference to ImageInfo structure with information on RAW data.</param>
             <param name="BufferInfo">Reference to ImageInfo structure in which the converted image is written.</param>
             <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
             <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
             <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FromRawToImage(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm,System.UInt32,System.UInt32,System.UInt32)">
             <summary>
             Convert from RAW to an image that can be saved or modified
             
             Convert the RAW image specified with AqImageInfo by the following rule, and store it in the area specified by BufferInfo.\n\n
             PixelFormat information for the converted image is returned in the BufferInfo structure:
             This function makes it possible to specify which Bayer Color Interpolation algorithm to be used.
             
             <TABLE>
             <TR><TD>AqImageInfo PixelFormat</TD><TD>BufferInfo PixelFormat</TD></TR>
             <TR><TD>8bpp Grayscale</TD><TD>8bpp Grayscale</TD></TR>
             <TR><TD>10-16bpp Grayscale</TD><TD>16bpp Grayscale (Shifted to MSB)</TD></TR>
             <TR><TD>24bpp RGB</TD><TD>24bpp BGR</TD></TR>
             <TR><TD>30bpp RGB</TD><TD>48bpp BGR (Shifted to MSB)</TD></TR>
             <TR><TD>8bpp Bayer</TD><TD>24bpp BGR</TD></TR>
             <TR><TD>10-12bpp Bayer</TD><TD>48bpp BGR (Shifted to MSB)</TD></TR>
             </TABLE>
             </summary>
             <remarks>
             If the <c>BayerFast</c> or the <c>BayerFastMultiprocessor</c> algorithms are used then the output buffer will 
             only have the half vertical and horizontal resolution of the input image!
             </remarks>
             <example>
             <code>
             // C# Sample that converts a raw image and saved the result to a file
             ...
             Jai_FactoryWrapper.EFactoryError error = Jai_FactoryWrapper.EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvertedImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Save the image to disk in TIFF format
                 error = J_Image_SaveFile(ref ConvertedImageInfo, FileName);
               }
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="AqImageInfo">Reference to ImageInfo structure with information on RAW data.</param>
             <param name="BufferInfo">Reference to ImageInfo structure in which the converted image is written.</param>
             <param name="BayerAlgorithm">Color interpolation algorithm.</param>
             <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
             <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
             <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ConvertImage(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Malloc(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@)">
             <summary>
             Allocate the buffer memory for the image
             
             Allocate the buffer to store the converted image.
             Information on the allocated buffer is returned in BufferInfo structure.
             </summary>
             <example>
             <code>
             // C# Sample that allocated an image buffer and frees it again
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               ... Do something with the image buffer
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="AqImageInfo">Reference to ImageInfo structure with information on RAW data.</param>
             <param name="BufferInfo">Reference to ImageInfo structure in which the information about the allocated buffer will be stored.</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_MallocDIB(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@)">
             <summary>
             Allocate the buffer memory for the DIB (32-bit ARGB)
             
             Allocate the buffer to store the converted image.
             Information on the allocated buffer is returned in BufferInfo structure.
             </summary>
             <example>
             <code>
             // C# Sample that allocated an DIB buffer and frees it again
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_MallocDIB(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               error = J_Image_RawToDIB(ref ImageInfo, ref ConvertedImageInfo, RGain, GGain, BGain);
               ... Do something with the DIB buffer
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="AqImageInfo">Reference to ImageInfo structure with information on RAW data.</param>
             <param name="BufferInfo">Reference to ImageInfo structure in which the information about the allocated buffer will be stored.</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Malloc(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat)">
             <summary>
             Allocate the buffer memory for the image to use <c>J_Image_ConvertImage()</c>
             
             Allocate the buffer to store the converted image to use <c>J_Image_ConvertImage()</c>.
             Information on the allocated buffer is returned in BufferInfo structure.
             </summary>
             <example>
             <code>
             // C# Sample that allocated an image buffer for use with the \c J_Image_ConvertImage() and frees it again
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, 
                                    ref ConvertedImageInfo, 
                                    EColorConversionPixelFormat.PixelFormatY);
             if (error == EFactoryError.Success)
             {
               error = J_Image_ConvertImage(ref ImageInfo, 
                                            ref ConvertedImageInfo, 
                                            EColorConversionPixelFormat.PixelFormatY);
               ... Do something with the Y image buffer
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="AqImageInfo">Reference to  ImageInfo structure with information on RAW data.</param>
             <param name="BufferInfo">Reference to  ImageInfo structure in which the information about the allocated buffer will be stored.</param>
             <param name="ConversionPixelFormat">Image conversion pixelformat option to be used in \c J_Image_ConvertImage()</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Free(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@)">
             <summary>
             Free a previously allocated image buffer.
             
             Frees the memory allocated for an image buffer using <c>J_Image_Malloc()</c>, <c>J_Image_MallocDIB()</c>
             or <c>J_Image_MallocHDR()</c>
             </summary>
             <example>
             <code>
             // C# Sample that allocated an image buffer and frees it again
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               ... Do something with the image buffer
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             \endcode
             </code>
             </example>
             <param name="BufferInfo">Reference to ImageInfo structure with a buffer previously allocated with \c J_Image_Malloc()</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SaveFile(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.String)">
             <summary>
             Save an image to disk as TIFF file
             
             Saves an image to disk as a TIFF file. A raw image needs to be converted using <c>J_Image_FromRawToImage()</c> before it can be saved
             </summary>
             <example>
             <code>
             // C# Sample that converts a raw image and saves the result to a file
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvertedImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Save the image to disk in TIFF format
                 error = J_Image_SaveFile(ref ConvertedImageInfo, FileName);
               }
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="BufferInfo">Reference to ImageInfo structure in which the information about the allocated buffer will be read.</param>
             <param name="FileName">Full file name and path of the tiff file to be stored to disk.</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SaveFileEx(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat,System.Byte)">
             <summary>
             Save an image to disk using various file formats such as TIFF, JPEG, BMP or JAI
             
             Saves an image to disk using different file formats. A raw image needs to be converted using <c>J_Image_FromRawToImage()</c> 
             before it can be saved unless the JAI RAW format is being used!
             </summary>
             <example>
             <code>
             // C# Sample that converts a raw image and saves the result to a file
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure
             ImageInfo ConvertedImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvertedImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvertedImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Save the image to disk in Jpeg format with quality factor 75
                 error = J_Image_SaveFileEx(ref ConvertedImageInfo, FileName, ESaveFileFormat.Jpeg, 75);
               }
             
               // Free up the image buffer again
               error = J_Image_Free(ref ConvertedImageInfo);
             }
             </code>
             </example>
             <param name="BufferInfo">Reference to ImageInfo structure in which the information about the allocated buffer will be read.</param>
             <param name="FileName">Full file name and path of the tiff file to be stored to disk.</param>
             <param name="FileFormat">File format to be used when saving the image.</param>
             <param name="EncoderParameter">Encoder parameter. The meaning of the value depends on which File format that is selected. If Jpeg file format is selected this parameter specifies the Quality level for the jpeg file. Acceptable value range is 1 to 100, default is 75, 5-95 is useful range. Larger number goes toward higher quality and larger file size.</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SaveFileRaw(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.String)">
            <summary>
            Save an image to disk as raw binary file
            
            Saves an image to disk as a raw binary file. The image data is saved without any header information so it is not possible to display the image directly.
            </summary>
            <param name="BufferInfo">Reference to ImageInfo structure in which the information about the image buffer is read.</param>
            <param name="FileName">Full file name and path of the raw binary file to be stored to disk.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_LoadFileRaw(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.String)">
            <summary>
            Load a previously saved RAW image file from disk.
            
            If the file was saved using <c>J_Image_SaveFileEx()</c> in <c>JAI</c> file format then the <c>BufferInfo</c> structure parameter will
            automatically be initialized with the proper values from the original image that was saved.
            If the file was saved using <c>J_Image_SaveFileRaw()</c> then the <c>BufferInfo</c> structure parameter will need to be
            initialized with the proper values by the application!.
            </summary>
            <remarks>
            This function will automatically allocated the correct amount of memory needed to hold the image data. Please remember to
            call <c>J_Image_Free(pBufferInfo)</c> when the image is not needed any more!
            </remarks>
            <param name="BufferInfo">Reference to ImageInfo structure in which the information about the image buffer will be written.</param>
            <param name="FileName">Full file name and path of the raw binary file to be loaded from disk.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetPixel(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue@)">
            <summary>
            Get the pixel at a specified position
            
            Read the current pixel value at the position <c>Point</c>. A raw image needs to be converted using <c>J_Image_FromRawToImage()</c> before pixels can be read.
            </summary>
            <param name="BufferInfo">Reference to ImageInfo structure in which the pixel value will be read.</param>
            <param name="Point">Absolute position in which pixel value is read.</param>
            <param name="Pixel">Pixel value data read from the image.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetPixelEx(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.Double,System.Double,Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue@)">
            <summary>
            Get the pixel at a specified floating-point position
            
            Read the current pixel value at the position <c>XPos,YPos</c>. A raw image needs to be converted using <c>J_Image_FromRawToImage()</c> before pixels can be read.
            The returned pixel value will be generated using bi-linear interpolation of nearest pixels.
            </summary>
            <param name="BufferInfo">Reference to ImageInfo structure in which the pixel value will be read.</param>
            <param name="XPos">Absolute X-position in which pixel value is read.</param>
            <param name="YPos">Absolute position in which pixel value is read.</param>
            <param name="Pixel">Pixel value data read from the image.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetPixel(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue@)">
            <summary>
            Set the pixel at a specified position
            
            Writes the current pixel value at the position <c>Point</c>. A raw image needs to be converted using <c>J_Image_FromRawToImage()</c> before pixels can be written.
            
            Where to set the actual values inside the <c>PixelValue</c> structure depends on the <c>PixelFormat</c> that can be read from <c>BufferInfo</c>.
            </summary>
            <param name="BufferInfo">ImageInfo structure in which the pixel value will be written.</param>
            <param name="Point">Absolute position in which pixel value is written.</param>
            <param name="Pixel">Pixel value data to write.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetAverage(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.RECT@,Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue@)">
            <summary>
            Measures pixel average value for a region in the image.
            </summary>
            <param name="BufferInfo">ImageInfo structure which contains a converted image.</param>
            <param name="MeasureRect">Measurement rectangular coordinates.</param>
            <param name="RGBAverage">Measured average pixel value for all the pixels inside the measurement rectangle. The pixel format for the PixelValue structure will always be in BGR48 format (16 bit per color)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetGain(System.IntPtr,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set RGB software gain.
            
            The gain is only used inside the factory when the <c>J_Image_OpenStreamLight()</c> has been used to display live video.
            
            This function doesn't return the white balance gain from inside the camera. It is only used inside the factory when 
            the <c>J_Image_OpenStreamLight()</c> has been used to display live video
            </summary>
            <param name="StreamHandle">Handle to the stream channel opened using <c>J_Image_OpenStream()</c> or <c>J_Image_OpenStreamLight()</c>.</param>
            <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetGain(System.IntPtr,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Get RGB software gain.
            
            The gain is only used inside the factory when the <c>J_Image_OpenStreamLight()</c> has been used to display live video.
            If <c>J_Image_ExecuteWhiteBalance()</c> has been called, the resulting gain values can be read with this function after the next 
            image has been received on the stream channel.
            
            This function doesn't affect the white balance settings inside the camera.
            </summary>
            <param name="StreamHandle">Handle to the stream channel opened using <c>J_Image_OpenStream()</c> or <c>J_Image_OpenStreamLight()</c>.</param>
            <param name="RGain">Gain for the red color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="GGain">Gain for the green color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <param name="BGain">Gain for the blue color channel for Bayer conversion (0x01000(4096) = 1.00)</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ExecuteWhiteBalance(System.IntPtr)">
            <summary>
            Calculate software auto white balance
            
            When this function has been called, the resulting gain values can be read with <c>J_Image_GetGain()</c> function after the next
            image has been received on the stream channel.
            The resulting white balance is only used inside the factory when the <c>J_Image_OpenStreamLight()</c> has been used to display live video.
            
            After executing this function, you can use the <c>J_Image_GetGain()</c> function to get the resulting gain values.
            
            This function doesn't affect the white balance settings inside the camera.
            </summary>
            <param name="StreamHandle">Handle to the stream channel opened using <c>J_Image_OpenStream()</c> or <c>J_Image_OpenStreamLight()</c>.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_MallocHDR(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@)">
            <summary>
            Allocate the buffer memory for the HDR output image.
            
            16-bit per pixel will be allocated and they will be 16-byte aligned in order to speed up the HDR processing.
            The allocated HDR image will need to be freed up using <c>J_Image_Free()</c>
            Information on the allocated buffer is returned in the J_tIMAGE_INFO structure.
            </summary>
            <remarks>
            The input images needs to be Mono8, Mono10, Mono12, Mono14 or Mono16 pixel format for monochrome images or Bayer8, Bayer10
            Bayer12 or Bayer16 for CFA color images or RGB8Packed, RGB10Packed, RGB12Packed or RGB16Packed for RGB color images.
            It is also required that the two images has got identical pixel format
            </remarks>
            <param name="ImageInfo1">Reference to ImageInfo structure with information on RAW data for first image.</param>
            <param name="ImageInfo2">Reference to ImageInfo structure with information on RAW data for second image.</param>
            <param name="BufferInfo">Reference to ImageInfo structure in which the information about the allocated buffer will be stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_AnalyzeHDR(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.Byte@,System.Int32@,System.Int32@,System.Single@)">
            <summary>
            Analyzes two images and try to determine the exposure difference (called Dark Gain) later to be used 
            as a parameter to the HDR fusing function <c>J_Image_FuseHDR()</c>
            
            This function runs through the image data from the two input images and try to determine the exposure difference
            between the two images by looking at the pixels with the highest values that are not saturated.
            It will break out the analysis when the gain start to become "unlinear" (when for instance the darkest image 
            values gets close to the black level).
            
            It will return ERROR if it didn't find any pixels where there is an "overlap" so it couldn't calculate the gain.
            The function also updates a flag that indicates whether Image 1 is brighter than Image 2. 
            
            The minimum values inside Image 1 and Image 2 are returned as recommended Black Level values.
            If none of the pixel values in any of the input images are as low as the black level then the estimated 
            black level will be wrong. This means that the black level values used in <c>J_Image_FuseHDR()</c> need to be set
            to a more correct value. A way to identify that this is the case is to compare the black level returned for the 
            two input images. If the black level value for the brightest image is more than twice the black levels of the dark
            image then the recommended black level for the bright image might very well be wrong.
            </summary>
            <remarks>
            The input images needs to be Mono8, Mono10, Mono12, Mono14 or Mono16 pixel format for monochrome images or Bayer8, Bayer10
            Bayer12 or Bayer16 for CFA color images or RGB8Packed, RGB10Packed, RGB12Packed or RGB16Packed for RGB color images.
            It is also required that the two images has got identical pixel format
            </remarks>
            <param name="ImageInfo1">Reference to ImageInfo structure with information on RAW data for first image.</param>
            <param name="ImageInfo2">Reference to ImageInfo structure with information on RAW data for second image.</param>
            <param name="Image1IsBrighter">Reference to flag that will be set to 1 if Image 1 is brighter than Image 2</param>
            <param name="BlackLevelImage1">Reference to an int value that will be updated with the recommended Black Level for Image 1 to be subtracted from the image data during HDR merging.</param>
            <param name="BlackLevelImage2">Reference to an int value that will be updated with the recommended Black Level for Image 2 to be subtracted from the image data during HDR merging.</param>
            <param name="DarkGain">Reference to a float value that will contain the gain between the two images.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FuseHDR(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,System.Int32,System.Int32,System.Single,System.Single,System.Byte)">
            <summary>
            Fuses two input images into a "High Dynamic Range" output image.
            
            This function will combine two input images into a HDR image by picking the unsaturated pixels from the 
            brightest image and wherever the brightest image is saturated it will instead use the pixel values from the 
            darkest of the two input images to create a replacement value for the saturated value. 
            </summary>
            <remarks>
            The input images needs to be Mono8, Mono10, Mono12, Mono14 or Mono16 pixel format for monochrome images or Bayer8, Bayer10
            Bayer12 or Bayer16 for CFA color images or RGB8Packed, RGB10Packed, RGB12Packed or RGB16Packed for RGB color images.
            It is also required that the two images has got identical pixel format
            </remarks>
            <param name="BrighterImageInfo">Reference to ImageInfo structure with information on the brighter of the two input images.</param>
            <param name="DarkerImageInfo">Reference to ImageInfo structure with information on the darker of the two input images.</param>
            <param name="OutputImage">Reference to ImageInfo structure that will receive the 16-bit HDR output image.</param>
            <param name="BrighterBlackLevel">Black Level to be subtracted from the Brighter Image during calculation.</param>
            <param name="DarkerBlackLevel">Black Level to be subtracted from the Brighter Image during calculation.</param>
            <param name="DarkGain">Gain value to be multiplied with the Darker Image pixel values when the Brighter Image pixels are saturated.</param>
            <param name="DualSlopeGain">Value to be multiplied with fDarkGain to produce "Dual Slope" effect.</param>
            <param name="LogarithmicOutput">Flag that will select if the HDR Output Image will be tranformed using log2() before it is converted into 16-bit unsigned integer values.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_MallocLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@)">
            <summary>
            Allocate the buffer memory for the LUT based on the pixel format read from the image buffer.
            
            The LUT will be initialized and the LUT memory will be allocated based on the pixel format read from the image.
            The allocated LUT will need to be freed up using <c>J_Image_FreeLUT()</c>
            </summary>
            <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FreeLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@)">
            <summary>
            Free the LUT memory previously allocated using <c>J_Image_MallocLUT()</c>.
            </summary>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ConvertLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@)">
            <summary>
            Convert an existing LUT into a different size and copy the data.
            </summary>
            <param name="SourceLUTInfo">Reference to LUTInfo structure with information on Source LUT.</param>
            <param name="DestinationLUTInfo">Reference to LUTInfo structure with information on Destination LUT.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_LUT(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@)">
            <summary>
            Process the image by sending all pixels through the LUT.
            
            All the pixels values in the image will be replaced with the corresponding value from the LUT.
            <remarks>
            The LUT has to be created using <c>J_Image_MallocLUT()</c> from an image with the identical pixel format 
            so the LUT has the correct dimension.
            </remarks>
            </summary>
            <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_CreateGammaLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.UInt32,System.Double)">
            <summary>
            This function creates a user-defined Gamma LUT and fills in the values to a LUT that has previously been 
            allocated using <c>J_Image_MallocLUT()</c>.
            </summary>
            <remarks>
            The LUT has to be created using <c>J_Image_MallocLUT()</c> before this function can be called.
            </remarks>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <param name="ColorIndex">Select the LUT color index to use. 0=Monochrome or Red, 1=Green, 2=Blue</param>
            <param name="gamma">Gamma value to be used</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ApplyGammaToLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.UInt32,System.Double)">
            <summary>
            This function applies a user-defined Gamma LUT to a LUT that has already been initialized with values.
            </summary>
            <remarks>
            The LUT has to be created using <c>J_Image_MallocLUT()</c> before this function can be called.
            </remarks>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <param name="ColorIndex">Select the LUT color index to use. 0=Monochrome or Red, 1=Green, 2=Blue</param>
            <param name="gamma">Gamma value to be applied to the exisiting LUT contents</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_CreateLinearLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_CreateKneeLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.UInt32,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetLUTValue(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.UInt32,System.UInt32,System.UInt32@)">
            <summary>
            This function directly reads a value from the LUT.
            </summary>
            <remarks>
            The LUT has to be created using <c>J_Image_MallocLUT()</c> before this function can be called.
            </remarks>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <param name="ColorIndex">Select the LUT color index to use. 0=Monochrome or Red, 1=Green, 2=Blue</param>
            <param name="LUTIndex">Zero-based index into the LUT.</param>
            <param name="pLUTValue">Reference to UInt32 variable where the LUT value is to be returned.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SetLUTValue(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            This function directly writes a value to the LUT.
            </summary>
            <remarks>
            The LUT has to be created using <c>J_Image_MallocLUT()</c> before this function can be called.
            </remarks>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <param name="ColorIndex">Select the LUT color index to use. 0=Monochrome or Red, 1=Green, 2=Blue</param>
            <param name="LUTIndex">Zero-based index into the LUT.</param>
            <param name="LUTValue">New UInt32 value to be entered into the LUT.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_SaveLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.String)">
            <summary>
            This function saves a LUT to disk as a binary file
            </summary>
            <remarks>
            The LUT has to be created using <c>J_Image_MallocLUT()</c> before this function can be called.
            </remarks>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <param name="FileName">Filename and path to where the LUT will be written.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_LoadLUT(Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo@,System.String)">
            <summary>
            This function loads a LUT from disk. If the LUT already contains data then it will be overwritten.
            </summary>
            <remarks>
            This function will automatically free any memory allocated for the existing LUT and allocate new memory
            that will be large enough to hold the LUT that is read from disk.
            </remarks>
            <param name="LUTInfo">Reference to LUTInfo structure with information on LUT.</param>
            <param name="FileName">Filename and path to the LUT file to be read.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_MallocHistogram(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo@)">
            <summary>
            Allocate the buffer memory for the Histogram based on the pixel format read from the image buffer.
            
            The Histogram will be initialized and the memory will be allocated based on the pixel format read from the image.
            The allocated Histogram will need to be freed up using <c>J_Image_FreeHistogram()</c>
            </summary>
            <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
            <param name="HistogramInfo">Reference to HistogramInfo structure with information on Histogram.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_FreeHistogram(Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo@)">
            <summary>
            Free the Histogram memory previously allocated using <c>J_Image_MallocHistogram()</c>.
            </summary>
            <param name="HistogramInfo">Reference to HistogramInfo structure with information on Histogram.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ClearHistogram(Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo@)">
            <summary>
            Clear the contents of the Histogram memory previously allocated using <c>J_Image_MallocHistogram()</c>.
            </summary>
            <param name="HistogramInfo">Reference to HistogramInfo structure with information on Histogram.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_CreateHistogram(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.RECT@,Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo@)">
            <summary>
            Creates the Histogram from the image contents.
            
            The Histogram will be has to be allocated in advance using <c>J_Image_MallocHistogram()</c>
            </summary>
            <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
            <param name="MeasureRect">Measurement rectangular coordinates.</param>
            <param name="HistogramInfo">Reference to HistogramInfo structure with information on Histogram.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_GetHistogramValue(Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo@,System.UInt32,System.UInt32,System.UInt32@)">
            <summary>
            This function directly reads a value from the Histogram.
            </summary>
            <remarks>
            The Histogram has to be created using <c>J_Image_MallocHistogram()</c> and initialized using <c>J_Image_CreateHistogram()</c> before this function can be called.
            </remarks>
            <param name="HistogramInfo">Reference to HistogramInfo structure with information on Histogram.</param>
            <param name="ColorIndex">Select the Histogram color index to use. 0=Monochrome or Red, 1=Green, 2=Blue</param>
            <param name="HistogramIndex">Zero-based index into the Histogram.</param>
            <param name="pHistogramValue">Reference to UInt32 variable where the Histogram value is to be returned.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Flip(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EFlipType)">
            <summary>
            Flip the image contents in the image buffer.
            </summary>
            <remarks>
            The input images needs to be 8, 10, 12, 14 or 16-bit Monochrome or Bayer-Color unpacked pixel format.
            </remarks>
            <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
            <param name="flipType">Flip type to be used</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Rotate(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ERotateType)">
            <summary>
            Rotate the image contents in the image buffer.
            </summary>
            <remarks>
            The input images needs to be 8, 10, 12, 14 or 16-bit Monochrome or Bayer-Color unpacked pixel format.
            </remarks>
            <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
            <param name="rotateType">Rotate type to be used</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Processing(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType,System.IntPtr)">
             <summary>
             This function processes the image by the function specified by the parameter.
             </summary>
             <example>
             <code>
             // C# Sample that perform Red-Compensation on a color image received from a camera.
             // This sample calls the "native" J_Image_Processing() instead of using the overloaded version in order to
             // illustrate the marshaling needed
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure to be used for the conversion between RAW and Image format
             ImageInfo ConvImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Perform the Red-Compensation on the full image:
                 // Start by setting up the Red-compensation parameter structure
                 Jai_FactoryWrapper.RedCompensationStruct myRedCompParam = new Jai_FactoryWrapper.RedCompensationStruct();
                 // Remember to allocate the 10 Red-compensation ROI structures
                 myRedCompParam.ColorCompensationROI = new Jai_FactoryWrapper.ColorCompensationROIStruct[10];
            
                 // We are going to use the full image as a ROI for the Red-Compensation
                 myRedCompParam.NumOfROI = 1;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Left = 0;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Right = (int)ImageInfo.SizeX - 1;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Top = 0;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Bottom = (int)ImageInfo.SizeY - 1;
                 myRedCompParam.ColorCompensationROI[0].RThreshold = myRedThreshold;
                 myRedCompParam.ColorCompensationROI[0].GThreshold = myGreenThreshold;
                 myRedCompParam.ColorCompensationROI[0].BThreshold = myBlueThreshold;
                 myRedCompParam.ColorCompensationROI[0].RGain = 4096 * myRedGainPercentage / 100;
                 myRedCompParam.ColorCompensationROI[0].GGain = 4096 * myGreenGainPercentage / 100;
                 myRedCompParam.ColorCompensationROI[0].BGain = 4096 * myBlueGainPercentage / 100;
            
                 // At this point we could call the overloaded J_Image_Processing() for Red-Compensation but 
                 // instead we will handle the Marshalling directly here instead to show how this could be done!
                 IntPtr pParameters;
             
                 // Allocates memory from the unmanaged memory of the process using GlobalAlloc
                 pParameters = Marshal.AllocHGlobal(Marshal.SizeOf(myRedCompParam));
            
                 try
                 {
                   // Marshals data from a managed object to an unmanaged block of memory 
                   Marshal.StructureToPtr(myRedCompParam, pParameters, false);
            
                   // Call the Red-Compensation Image Processing algorithm
                   error = J_Image_Processing(ref ConvImageInfo, EProcessFunctionType.RedCompensation, pParameters);
                 }
                 finally
                 {
                   // Frees memory previously allocated from the unmanaged memory of the process with AllocHGlobal
                   Marshal.FreeHGlobal(pParameters);
                 }
               }
             
               // Free up the image conversion buffer again
               error = J_Image_Free(ref ConvImageInfo);
             }
             </code>
             </example>
             <param name="ImageInfo">Reference to ImageInfo structure with information on the image data.</param>
             <param name="ProcessingFunction">Type of image processing to be performed</param>
             <param name="Parameters">Pointer to an unmanaged structure containing the image processing parameters</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ProcessingEx(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType,System.IntPtr)">
             <summary>
             This function processes the image by the function specified by the parameter. The output is written to an image that is
             different from the input image.
             </summary>
             <example>
             <code>
             // C# Sample that perform Red-Compensation on a color image received from a camera.
             // This sample calls the "native" J_Image_ProcessingEx() instead of using the overloaded version in order to
             // illustrate the marshaling needed
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure to be used for the conversion between RAW and Image format
             ImageInfo ConvImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Perform the Red-Compensation on the full image:
                 // Start by setting up the Red-compensation parameter structure
                 Jai_FactoryWrapper.RedCompensationStruct myRedCompParam = new Jai_FactoryWrapper.RedCompensationStruct();
                 // Remember to allocate the 10 Red-compensation ROI structures
                 myRedCompParam.ColorCompensationROI = new Jai_FactoryWrapper.ColorCompensationROIStruct[10];
            
                 // We are going to use the full image as a ROI for the Red-Compensation
                 myRedCompParam.NumOfROI = 1;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Left = 0;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Right = (int)ImageInfo.SizeX - 1;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Top = 0;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Bottom = (int)ImageInfo.SizeY - 1;
                 myRedCompParam.ColorCompensationROI[0].RThreshold = myRedThreshold;
                 myRedCompParam.ColorCompensationROI[0].GThreshold = myGreenThreshold;
                 myRedCompParam.ColorCompensationROI[0].BThreshold = myBlueThreshold;
                 myRedCompParam.ColorCompensationROI[0].RGain = 4096 * myRedGainPercentage / 100;
                 myRedCompParam.ColorCompensationROI[0].GGain = 4096 * myGreenGainPercentage / 100;
                 myRedCompParam.ColorCompensationROI[0].BGain = 4096 * myBlueGainPercentage / 100;
            
                 // At this point we could call the overloaded J_Image_Processing() for Red-Compensation but 
                 // instead we will handle the Marshalling directly here instead to show how this could be done!
                 IntPtr pParameters;
             
                 // Allocates memory from the unmanaged memory of the process using GlobalAlloc
                 pParameters = Marshal.AllocHGlobal(Marshal.SizeOf(myRedCompParam));
            
                 try
                 {
                   // Marshals data from a managed object to an unmanaged block of memory 
                   Marshal.StructureToPtr(myRedCompParam, pParameters, false);
            
                   // Call the Red-Compensation Image Processing algorithm
                   error = J_Image_ProcessingEx(ref ConvImageInfo, IntPtr.Zero, EProcessFunctionType.RedCompensation, pParameters);
                 }
                 finally
                 {
                   // Frees memory previously allocated from the unmanaged memory of the process with AllocHGlobal
                   Marshal.FreeHGlobal(pParameters);
                 }
               }
             
               // Free up the image conversion buffer again
               error = J_Image_Free(ref ConvImageInfo);
             }
             </code>
             </example>
             <param name="InputImageInfo">Reference to ImageInfo structure with information on the input image data.</param>
             <param name="OutputImageInfo">Reference to ImageInfo structure with information on the output image data.</param>
             <param name="ProcessingFunction">Type of image processing to be performed</param>
             <param name="Parameters">Pointer to an unmanaged structure containing the image processing parameters</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Processing(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.RedCompensationStruct,System.Boolean)">
             <summary>
             This function performs a Red-Compensation on the image.
             </summary>
             <example>
             <code>
             // C# Sample that perform Red-Compensation on a color image received from a camera.
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure to be used for the conversion between RAW and Image format
             ImageInfo ConvImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Perform the Red-Compensation on the full image:
                 // Start by setting up the Red-compensation parameter structure
                 Jai_FactoryWrapper.RedCompensationStruct myRedCompParam = new Jai_FactoryWrapper.RedCompensationStruct();
                 // Remember to allocate the 10 Red-compensation ROI structures
                 myRedCompParam.ColorCompensationROI = new Jai_FactoryWrapper.ColorCompensationROIStruct[10];
            
                 // We are going to use the full image as a ROI for the Red-Compensation
                 myRedCompParam.NumOfROI = 1;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Left = 0;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Right = (int)ImageInfo.SizeX - 1;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Top = 0;
                 myRedCompParam.ColorCompensationROI[0].RectOfROI.Bottom = (int)ImageInfo.SizeY - 1;
                 myRedCompParam.ColorCompensationROI[0].RThreshold = myRedThreshold;
                 myRedCompParam.ColorCompensationROI[0].GThreshold = myGreenThreshold;
                 myRedCompParam.ColorCompensationROI[0].BThreshold = myBlueThreshold;
                 myRedCompParam.ColorCompensationROI[0].RGain = 4096 * myRedGainPercentage / 100;
                 myRedCompParam.ColorCompensationROI[0].GGain = 4096 * myGreenGainPercentage / 100;
                 myRedCompParam.ColorCompensationROI[0].BGain = 4096 * myBlueGainPercentage / 100;
            
                 retsta = Jai_FactoryWrapper.J_Image_Processing(ref ConvImageInfo, myRedCompParam, true);
               }
             
               // Free up the image conversion buffer again
               error = J_Image_Free(ref ConvImageInfo);
             }
             </code>
             </example>
             <param name="ImageInfoRef">Reference to ImageInfo structure with information on the image data.</param>
             <param name="RedCompensationParameters">Red-Compensation processing parameters</param>
             <param name="UseMultiProcessor">use multi-processor aware algorithm</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Processing(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.GreenCompensationStruct,System.Boolean)">
            <summary>
            This function performs a Green-Compensation on the image.
            </summary>
            <param name="ImageInfoRef">Reference to ImageInfo structure with information on the image data.</param>
            <param name="GreenCompensationParameters">Green-Compensation processing parameters</param>
            <param name="UseMultiProcessor">use multi-processor aware algorithm</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Processing(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct,System.Boolean)">
             <summary>
             This function performs a Lens Distortion Correction on the image.
             </summary>
             <example>
             <code>
             // C# Sample that perform Lens Distortion Correction on a color image received from a camera.
             
             // The processing speed of the Lens Distortion Correction will be much faster if this internal map 
             // is initialized by calling Jai_FactoryWrapper.J_Image_ProcessingInit(ref ConvImageInfo, myUndistortParam);
             ...
             EFactoryError error = EFactoryError.Success;
             
             // Create Image info structure to be used for the conversion between RAW and Image format
             ImageInfo ConvImageInfo = new ImageInfo();
            
             // Allocate the buffer to hold converted the image
             error = J_Image_Malloc(ref ImageInfo, ref ConvImageInfo);
             if (error == EFactoryError.Success)
             {
               // Convert the raw image to image format
               error = J_Image_FromRawToImage(ref ImageInfo, ref ConvImageInfo, RedGain, GreenGain, BlueGain);
               if (error == EFactoryError.Success)
               {
                 // Perform the Lens Distortion Correction:
                 // Start by setting up the Undistort parameter structure
                 Jai_FactoryWrapper.UndistortStruct myUndistortParam = new Jai_FactoryWrapper.UndistortStruct();
            
                 // The lens distortion parameters need to be determined via a calibration process
                 myUndistortParam.OpticalCenterX = myOpticalCenterX; // Typically close to the image centre (ImageInfo.SizeX/2)
                 myUndistortParam.OpticalCenterY = myOpticalCenterY; // Typically close to the image centre (ImageInfo.SizeY/2)
                 myUndistortParam.FocalLengthX = myFocalLengthX;     // Typically the image width (ImageInfo.SizeX)
                 myUndistortParam.FocalLengthY = myFocalLengthY;     // Typically the image width (ImageInfo.SizeX)
                 myUndistortParam.CoeffK1 = myCoeffK1;               // Depending on lens (around -0.33246 for a std. 4mm lens)
                 myUndistortParam.CoeffK2 = myCoeffK2;               // Depending on lens (around  0.01839 for a std. 4mm lens)
                 myUndistortParam.CoeffK3 = myCoeffK3;               // Depending on lens (0.0 unless it is a fish-eye lens)
                 myUndistortParam.CoeffP1 = myCoeffP1;               // Depending on lens (around -0.00020 for a std. 4mm lens)
                 myUndistortParam.CoeffP2 = myCoeffP2;               // Depending on lens (around  0.00022 for a std. 4mm lens)
                 myUndistortParam.InterpolationType = EInterpolationType.InterpolationBiLinear;
                 retsta = Jai_FactoryWrapper.J_Image_Processing(ref ConvImageInfo, myUndistortParam, true);
               }
             
               // Free up the image conversion buffer again
               error = J_Image_Free(ref ConvImageInfo);
             }
             ...
             // When the Lens Distortion Correction is no longer needed then the internal undistort map needs to be release
             // by calling Jai_FactoryWrapper.J_Image_ProcessingFree(myUndistortParam);
             </code>
             </example>
             <param name="InputImageInfoRef">Reference to ImageInfo structure with information on the input image data.</param>
             <param name="OutputImageInfoRef">Reference to ImageInfo structure with information on the output image data.</param>
             <param name="UndistortParameters">Lens Distortion Correction parameters</param>
             <param name="UseMultiProcessor">use multi-processor aware algorithm</param>
             <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ProcessingInit(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct@)">
            <summary>
            This function allocates and initializes an internal undistort map so the following Lens Distortion Correction calls will be sped up considerably.
            
            This has to be called once before starting the Lens Distortion Correction and it will have to be called if any of the correction parameters are changed!
            </summary>
            <param name="InputImageInfoRef">Reference to ImageInfo structure with information on the input image data.</param>
            <param name="UndistortParameters">Lens Distortion Correction parameters</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_ProcessingFree(Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@,Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct@)">
            <summary>
            This function releases the memory allocated to the internal undistort map.
            </summary>
            <param name="InputImageInfoRef">Reference to ImageInfo structure with information on the input image data.</param>
            <param name="UndistortParameters">Lens Distortion Correction parameters</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetNumberOfTransportLayers(System.IntPtr,System.UInt32@)">
            @}
            \defgroup GENERIC_FACTORY   Generic GenTL functions
            \brief Support for access to generic device using the GenTL functions.
            @{
            
            \defgroup WRAP_TRANSPORTS   Transport layer specific functions
            @{
            <summary>
            Get the number of GenTL transport layers found after call to <c> J_Factory_Open()</c>.
            </summary>
            <param name="FactoryHandle">           Handle to a valid factory object, obtained by <c> J_Factory_Open()</c> function.</param>
            <param name="iNum">           Pointer to a variable in which the number of cameras is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetTransportLayerByIndex(System.IntPtr,System.UInt32,System.IntPtr@,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Get the name of the GenTL transport layer found after call to <c> J_GenTL_GetNumberOfTransportLayers()</c>.
            </summary>
            <param name="FactoryHandle">             Handle to a valid factory object, obtained by <c> J_Factory_Open()</c> function.</param>
            <param name="iIndex">           The zero-based index of the transport layer, which must be less than the value obtained from <c> J_GenTL_GetNumberOfTransportLayers()</c> function.</param>
            <param name="hTransport">      Pointer to a variable in which a handle of the transport layer object is stored.</param>
            <param name="TransportLayerID">          Pointer to a buffer in which the transport layer name is stored.</param>
            <param name="iSize">			Specify the size of the buffer. It must be equal or greater then <c> J_FACTORY_INFO_SIZE.</c> </param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_TLUpdateInterfaceList(System.IntPtr,System.Boolean@,System.UInt64)">
            <summary>
            Update a list of all interfaces connected to the specified transport layer.
            </summary>
            <param name="hTransport">        Handle to a valid transport layer object, obtained by <c> J_GenTL_GetTransportLayerByIndex()</c> </param>
            <param name="bHasChanged">       A bool that tells if there is found any new interfaces.</param>
            <param name="timeout">           Timeout for the update operation. Not currently used.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_TLGetNumInterfaces(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of GenTL interfaces found after call to <c> J_GenTL_TLUpdateInterfaceList()</c>.
            </summary>
            <param name="hTransport">       Handle to a valid transport layer object, obtained by <c> J_GenTL_GetTransportLayerByIndex()</c> </param>
            <param name="iNumInterfaces">   Pointer to a variable in which the number of GenTL interfaces connected to the specified transport layer.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_TLGetInterfaceID(System.IntPtr,System.UInt32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the name of the GenTL interfaces found after call to <c> J_GenTL_TLGetNumInterfaces()</c>.
            </summary>
            <param name="hTransport">     Handle to a valid transport layer object, obtained by <c>J_GenTL_GetTransportLayerByIndex()</c> </param>
            <param name="iIndex">         The zero-based index of the interface, which must be less than the value obtained from <c>J_GenTL_TLGetNumInterfaces()</c> function.</param>
            <param name="pBuffer">        Pointer to a buffer in which the interface layer name is stored.</param>
            <param name="iSize">		  Specify the size of the buffer, and then the function sets an actual size of stored data.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_TLOpenInterface(System.IntPtr,System.String,System.IntPtr@)">
            <summary>
            Open an interface from a interface ID and return valid camera handle.
            </summary>
            <param name="hTransport">       Handle to a valid transport layer object, obtained by <c>J_GenTL_GetTransportLayerByIndex()</c> </param>
            <param name="sInterfaceName">   Interface ID obtained by <c>J_GenTL_TLGetInterfaceID()</c> function.</param>
            <param name="hInterface">       Pointer to the variable in which the handle is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_IFUpdateDeviceList(System.IntPtr,System.Boolean@,System.UInt64)">
            @}
            \defgroup WRAP_INTERFACES   Interface layer specific functions
            @{
            <summary>
            Update a list of all local devices connected to the specified interface.
            </summary>
            <param name="hInterface">				Handle to a valid interface layer object, obtained by <c>J_GenTL_TLOpenInterface()</c> </param>
            <param name="bChanged">        A pointer to a bool that tells if there is found any new devices.</param>
            <param name="iTimeout">          Timeout for the update operation. Not currently used.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_IFGetNumDevices(System.IntPtr,System.UInt32@)">
            <summary>
            Get the number of GenTL local devices found after call to <c>J_GenTL_IFUpdateDeviceList()</c> .
            </summary>
            <param name="hInterface">			Handle to a valid interface layer object, obtained by  <c>J_GenTL_TLOpenInterface()</c> </param>
            <param name="NumDevices">           Pointer to a variable in which the number of GenTL local devices connected to the specified transport layer.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_IFGetDeviceName(System.IntPtr,System.UInt32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Get the name of the GenTL local device found after call to <c>J_GenTL_IFGetNumDevices()</c> .
            </summary>
            <param name="hInterface">	  Handle to a valid interface layer object, obtained by  <c>J_GenTL_TLOpenInterface()</c> </param>
            <param name="iIndex">         The zero-based index of the device, which must be less than the value obtained from  <c>J_GenTL_IFGetNumDevices()</c> function.</param>
            <param name="sIDeviceID">     Pointer to a buffer in which the interface layer name is stored.</param>
            <param name="iSize">		  Specify the size of the buffer, and then the function sets an actual size of stored data.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_IFOpenDevice(System.IntPtr,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags,System.IntPtr@)">
            <summary>
            Open a local device from a device name and return valid device handle.
            </summary>
            <param name="hInterface">		Handle to a valid interface layer object, obtained by  <c>J_GenTL_TLOpenInterface()</c> </param>
            <param name="sDevName">         Device name obtained by  <c>J_GenTL_IFGetDeviceName()</c> function.</param>
            <param name="iOpenFlags">       Device access Flags</param>
            <param name="hDevice">          Pointer to the variable in which the handle is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_DevGetPort(System.IntPtr,System.IntPtr@)">
            @}
            \defgroup WRAP_DEVICES   Device layer specific functions
            @{
            <summary>
            Retrieves the port handle for the associated remote device.
            This function does not return the handle for the Port functions for the Device module but for
            the physical remote device.
            </summary>
            <param name="hDevice">  	   Handle to a valid local device object, obtained by  <c>J_GenTL_IFOpenDevice()</c> </param>
            <param name="hRemoteDevice">   Pointer to the variable in which the handle is stored.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetNumPortURLs(System.IntPtr,System.UInt32@)">
            @}
            \defgroup WRAP_PORTS           Port specific functions
            @{
            <summary>
            Set the current port URL
            </summary>
            <param name="hCam">  	       Handle to a valid port object, obtained by  <c>J_GenTL_DevGetPort()</c> </param>
            <param name="pNumURLs">       Index of URL to load.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_PortSetURL(System.IntPtr,System.UInt32)">
            @}
            \defgroup WRAP_PORTS           Port specific functions
            @{
            <summary>
            Set the current port URL
            </summary>
            <param name="hCam">  	       Handle to a valid port object, obtained by  <c>J_GenTL_DevGetPort()</c> </param>
            <param name="nUrlIndex">       Index of URL to load.</param>
            <returns>Jai_FactoryWrapper.EFactoryError Errorcode returned by the factory</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,System.IntPtr@)" -->
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Is_GigE_Transport_Layer(System.IntPtr,System.Boolean@)">
            @}
            \defgroup WRAP_HELPER   Helper functions
            @{
            <summary>
            Helper function to determine if the handle returned by  <c>J_GenTL_GetTransportLayerByIndex()</c>
            is a JAI GigE transport layer. If pResult is true, the original SDK functions may be used
            to access the device; otherwise the generic GenTL functions above must be used.
            </summary>
            <param name="hTransport">     Handle to a valid transport layer object, obtained by  <c>J_GenTL_GetTransportLayerByIndex()</c> </param>
            <param name="bResult">		  Pointer to the variable in which the result is stored. The value is "true" if the transport layer</param>
            <returns>Jai_FactoryWrapper.EFactoryError Error code returned by the factory</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_IFClose(System.IntPtr,System.IntPtr)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetNumOfNodes(System.IntPtr,System.UInt32@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetTransportLayerByName(System.IntPtr,System.Text.StringBuilder,System.IntPtr@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_Event_GetData(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData@,System.UInt32@,System.UInt64)">
            <summary>
            Retrieve the event data associated with the event.
            
            The data type returned by this function will depend on the event type. If the event is of type <c>EDeviceEventType.NEW_BUFFER</c> then this
            function will return the image buffer handle as described by the <c>DeviceEventData.NEW_BUFFER_BufferHandle</c> structure value.
            If the event is of type <c>EDeviceEventType.GEV_EVENT_CMD</c> then this function will return information about the GEV command as 
            described by the <c>DeviceEventData.GEV_EVENT_CMD_xxx</c> structure values.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Camera_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_RegisterEvent(System.IntPtr,Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.IntPtr@)"/>
            <param name="EventHandle">Internal event handle obtained by the <c>J_Camera_RegisterEvent()</c> or <c>J_DataStream_RegisterEvent()</c> functions.</param>
            <param name="EventData">Reference to a <c>DeviceEventData</c> structure in which the information is stored.</param>
            <param name="Size">The size of the structure. The function sets the actual size of data stored into the buffer.</param>
            <param name="iTimeout">Timeout for the wait in ms.  A value of 0 checks the state of the event object and returns immediately either with a timeout or with event data.</param>
            <returns><c>Jai_FactoryWrapper.EFactoryError</c>. If no events are available in the event queue <c>EFactoryError.NoData</c> will be returned.</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetNodeByName(System.IntPtr,System.String,System.IntPtr@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetSubFeatureByIndex(System.IntPtr,System.String,System.UInt32,System.IntPtr@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_GetNumOfSubFeatures(System.IntPtr,System.String,System.UInt32@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_GenTL_IFGetDeviceInfoString(System.IntPtr,System.IntPtr,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType,System.Text.StringBuilder,System.UInt32@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_TranslatePixelFormats(System.IntPtr)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_Get_PixelFormat(System.IntPtr,System.UInt64,System.UInt64@)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_Camera_Link_Probe(System.Text.StringBuilder,System.Text.StringBuilder,System.Text.StringBuilder,System.Text.StringBuilder,System.Text.StringBuilder,System.UInt32,System.String)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DisableLogging">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_ReplaceEnvironmentVariables(System.Text.StringBuilder,System.UInt32)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_EnableLoggingFromFile(System.String)">
            
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_EnableLogging(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String)">
            
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError">
            <summary>
            Error return code enumeration.
            
            This is returned by all <c>Jai_Factory.dll</c> wrapper functions
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.Success">
            <summary>
            OK
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.Error">
            <summary>
            Generic errorcode
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.NotInitialized">
            <summary>
            GenTL NotInitialized
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.NotImplemented">
            <summary>
            GenTL NotImplemented
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.ResourceInUse">
            <summary>
            GenTL ResourceInUse
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.AccessDenied">
            <summary>
            Access denied
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.InvalidHandle">
            <summary>
            Invalid handle
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.InvalidID">
            <summary>
            Invalid ID
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.NoData">
            <summary>
            No data
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.InvalidParameter">
            <summary>
            Invalid parameter
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.FileIO">
            <summary>
            File IO error
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.Timeout">
            <summary>
            Timeout
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.Abort">
            <summary>
            Abort
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.InvalidBufferSize">
            <summary>
            Invalid buffer size
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.NotAvailable">
            <summary>
            GenTL Not available
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.InvalidAddress">
            <summary>
            Invalid address
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.CustomID">
            <summary>
            Custom error messages begin here
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.InvalidFilename">
            <summary>
            Invalid file name
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.GenICamError">
            <summary>
            Exception caught from GenApi code. Use <c>J_Factory_GetGenICamErrorInfo()</c> to get information string
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.ValidationError">
            <summary>
            Validation error found in <c>J_Camera_LoadSettings()</c>. Use <c>J_Camera_GetValidationErrorInfo()</c> to get information string
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryError.ValidationWarning">
            <summary>
            Validation warning found in <c>J_Camera_LoadSettings()</c>. Use <c>J_Camera_GetValidationErrorInfo()</c> to get information string
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">
            <summary>
            JAI SDK Factory Exceptions
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Message string</param>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Message string</param>
            <param name="inner">Inner exception</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryInfoType">
            <summary>
            Factory information type enumeration.
            
            This enumeration is used in the <c>J_Factory_GetInfo()</c> function to retrieve detailed information about the <c>Jai_Factory.dll</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryInfoType.Version">
            <summary>
            <c>Jai_Factory.dll</c> Version
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryInfoType.BuildDate">
            <summary>
            <c>Jai_Factory.dll</c> Build Date
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryInfoType.BuildTime">
            <summary>
            <c>Jai_Factory.dll</c> Build Time
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFactoryInfoType.Manufacturer">
            <summary>
            <c>Jai_Factory.dll</c> Manufacturer
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType">
            <summary>
            Camera information type enumeration.
            
            This enumeration is used in <c>J_Factory_GetCameraInfo()</c> to acquire detailed information about each detected camera.
            
            The camera connection does not need to be established in order to get this information. The information is retrieved during Device Discovery.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Factory_GetCameraInfo(System.IntPtr,System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType,System.Text.StringBuilder,System.UInt32@)"/>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.Manufacturer">
            <summary>
            Manufacturer Name
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.ModelName">
            <summary>
            Model Name
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.IPAddress">
            <summary>
            IP Address
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.MACAddress">
            <summary>
            MAC Address
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.SerialNumber">
            <summary>
            Serial Number
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.UserName">
            <summary>
            User defined Name
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECameraInfoType.InterfaceID">
            <summary>
            Interface ID
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.GenICamErrorInfo">
            <summary>
            GenICam Error Info
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.Jai_FactoryWrapper.GenICamErrorInfo.Description">
            <summary>
            Error description
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.Jai_FactoryWrapper.GenICamErrorInfo.NodeName">
            <summary>
            GenICam Node Name
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck">
            <summary>
            Action Command Acknowledge structure
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck.Status">
            <summary>
            GEV::STATUS of the ACK.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck.Type">
            <summary>
            GEV::GVCP of the packet.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck.Length">
            <summary>
            Number of bytes after the header.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck.ID">
            <summary>
            ACK ID to match incomming CMD.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck.IPAddress">
            <summary>
            IP address of the device that sent the Action Command Acknowledge
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags">
            <summary>
            Camera access mode flag enumeration.
            
            This enumeration is used in <c>J_Camera_OpenMc()</c> to specify the access mode when connecting to a camera.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags.UNKNOWN">
            <summary>
            Access denied
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags.None">
            <summary>
            Host has / can have Read Only access to the device
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags.ReadOnly">
            <summary>
            Host has / can have Read Only access to the device
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags.Control">
            <summary>
            Host has / can have Control access to the device
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags.Exclusive">
            <summary>
            Host has / can have Exclusive access to the device
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType">
            <summary>
            XML-file configuration information type enumeration
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.ModelName">
            <summary>
            Model Name (CV-A70GE...)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.VendorName">
            <summary>
            Vendor Name (JAI)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.ToolTip">
            <summary>
            Tooltip. Short description about the configuration file
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.StandardNameSpace">
            <summary>
            Standard Name Space (GigE Vision, IEEE...)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.GenApiVersion">
            <summary>
            GenAPI Version
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.SchemaVersion">
            <summary>
            GenICam Schema Version
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.DeviceVersion">
            <summary>
            Device Version
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.ProductGuid">
            <summary>
            Product GUID. Unique identifier for the camera. This will be unique to the camera type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfInfoType.VersionGuid">
            <summary>
            Version GUID. Unique identifier for the XML-file version. This will help to identify the current XML-file version
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility">
            <summary>
            Recommended visibility of an GenICam node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility.Beginner">
            <summary>
            Always visible
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility.Expert">
            <summary>
            Visible for experts or Gurus
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility.Guru">
            <summary>
            Visible for Gurus
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility.Invisible">
            <summary>
            Not Visible
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility._UndefinedVisibility">
            <summary>
            Object is not yet initialized
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType">
            <summary>
            The GenICam interface node type of a specific node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.UnknowNodeType">
            <summary>
            Unknown node type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.INode">
            <summary>
            INode node (all nodes are derived from this type)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.ICategory">
            <summary>
            ICategory node. Represent the Category grouping node type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IInteger">
            <summary>
            IInteger node. An 64-bit integer type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IEnumeration">
            <summary>
            IEnumeration node. Enumeration type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IEnumEntry">
            <summary>
            IEnumEntry node. Enumeration entry type that contains the value of an emumeration
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IMaskedIntReg">
            <summary>
            IMaskedIntReg node. Masked integer register node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IRegister">
            <summary>
            IRegister node. Register node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IIntReg">
            <summary>
            IIntReg node. Integer register node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IFloat">
            <summary>
            IFloat node. Floating point node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IFloatReg">
            <summary>
            IFloatReg node. Floating point register node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.ISwissKnife">
            <summary>
            ISwissKnife node. Special node used for doing calculations and conversions
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IIntSwissKnife">
            <summary>
            IIntSwissKnife node. Special node used for doing integer calculations and conversions
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IIntKey">
            <summary>
            IIntKey node. Integer key node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.ITextDesc">
            <summary>
            ITextDesc node. Text description node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IPort">
            <summary>
            IPort node. Generic port node.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IConfRom">
            <summary>
            IConfRom node. Configuration node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IAdvFeatureLock">
            <summary>
            IAdvFeatureLock node. Advanced feature lock node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.ISmartFeature">
            <summary>
            ISmartFeature node. Smart feature node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IStringReg">
            <summary>
            IStringReg node. String register node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IBoolean">
            <summary>
            IBoolean node. Boolean node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.ICommand">
            <summary>
            ICommand node. Command node that can execute a predefined command
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IConverter">
            <summary>
            IConverter node. Special node used for conversion
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IIntConverter">
            <summary>
            IIntConverter node. Special node used for integer conversion
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IChunkPort">
            <summary>
            IChunkPort node.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.INodeMap">
            <summary>
            INodeMap node.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.INodeMapDyn">
            <summary>
            INodeMapDyn node.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IDeviceInfo">
            <summary>
            IDeviceInfo node.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.ISelector">
            <summary>
            ISelector node.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNodeType.IPortConstruct">
            <summary>
            IPortConstruct node 
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode">
            <summary>
            Access mode of a GenICam node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode.NI">
            <summary>
            Not implemented access mode
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode.NA">
            <summary>
            Not available access mode
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode.WO">
            <summary>
            Write Only access mode
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode.RO">
            <summary>
            Read Only access mode
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode.RW">
            <summary>
            Read and Write access mode
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode._UndefinedAccesMode">
            <summary>
            Object is not yet initialized
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNameSpace">
            <summary>
            Defines if a node name is standard or custom namespace
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNameSpace.Custom">
            <summary>
            Name resides in custom namespace
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNameSpace.Standard">
            <summary>
            Name resides in one of the standard namespaces
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfNameSpace._UndefinedNameSpace">
            <summary>
            Object is not yet initialized
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfCachingMode">
            <summary>
            Caching mode of a GenICam register node
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfCachingMode.NoCache">
            <summary>
            Do not use cache
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfCachingMode.WriteThrough">
            <summary>
            Write to cache and register
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfCachingMode.WriteAround">
            <summary>
            Write to register, write to cache on read
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfCachingMode._UndefinedCachingMode">
            <summary>
            Not yet initialized
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation">
            <summary>
            Defines the node representation in the GUI
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.Linear">
            <summary>
            Linear
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.Logarithmic">
            <summary>
            Logarithmic
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.Boolean">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.PureNumber">
            <summary>
            Pure number
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.HexNumber">
            <summary>
            Hex number
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.IPV4Address">
            <summary>
            IP version 4 address (like 192.169.1.2)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation.MACAddress">
            <summary>
            MAC address (aa:bb:cc:dd:ee:ff)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EConfRepresentation._UndefinedRepresentation">
            <summary>
            Object is not yet initialized
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EDisplayNotation">
            <summary>
            Defines the IFloat Display Notation in the GUI
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDisplayNotation.Automatic">
            <summary>
            Automatic (the notation if either scientific or fixed depending on what is shorter)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDisplayNotation.Fixed">
            <summary>
            Fixed (the notation is fixed, e.g. 123.4)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDisplayNotation.Scientific">
            <summary>
            Scientific (the notation is scientific, e.g. 1.234e2)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDisplayNotation._UndefinedEDisplayNotation">
            <summary>
            Object is not yet initialized
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageCallBack">
            <summary>
            Delegate to be called as callback function when a new image has been received
            </summary>
            <param name="ImageInfo">Image information to be used in the image function</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ConnectionStatusCallBack">
            <summary>
            Delegate to be called as callback function when a new image has been received
            </summary>
            <param name="camera">Camera object</param>
            <param name="connectionStatus">New connection status value reported by the Transport Layer</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.GEVEventCallBack">
            <summary>
            Delegate to be called as callback function when a new GigE Vision Event has been received
            </summary>
            <param name="camera">Camera object</param>
            <param name="EventID">GigE Vision EVENT ID received from the camera</param>
            <param name="StreamChannelIndex">Stream Channel index if the GigE Vision EVENT is related to the stream channel. (0xFFFF for no channel)</param>
            <param name="BlockID">Data block ID (0 for no block).</param>
            <param name="Timestamp">Event timestamp (0 if not supported). The unit is device specific ticks</param>
            <param name="EventData">Event specific data associated with the event</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.NodeEventCallBack">
            <summary>
            Delegate to be called as callback function when a new Node Event has been received
            </summary>
            <param name="node">GenICam Node object</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveSettingsFlag">
            <summary>
            Defines the Save Settings flags used in J_Camera_SaveSettings()
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveSettingsFlag.Auto">
            <summary>
            Auto: Save all camera settings to disk. If the usage of the GenICam Streamable flags is detected then it will be used. Otherwise all features that are both Readable and Writable will be saved
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveSettingsFlag.StreamableOnly">
            <summary>
            Streamable Only: Force the persistence algorithm to use the GenICam Streamable flag. All features that have the Streamable flag set and are both Readable and Writable will be saved
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveSettingsFlag.ForceAll">
            <summary>
            Force All: Force the persistence algorithm to ignore the GenICam Streamable flag and save all features that are both Readable and Writable
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ELoadSettingsFlag">
            <summary>
            Defines the Load Settings flags used in J_Camera_LoadSettings()
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ELoadSettingsFlag.Auto">
            <summary>
            Auto: Load all camera settings from disk and validate the settings before writing the values to the camera. If the validation fails then a detailed validation error information will be available using the \c J_Camera_GetSettingsValidationErrorInfo() function. If a validation error is detected then the writing to the camera will be aborted.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ELoadSettingsFlag.ValidateOnly">
            <summary>
            Validate Only: Load all camera settings from disk and validate the settings. The values will not be written to the camera. If the validation fails then a detailed validation error information will be available using the \c J_Camera_GetSettingsValidationErrorInfo() function.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ELoadSettingsFlag.ForceWrite">
            <summary>
            Force Write: Force all the settings to be written to the camera without validating the feature names or the values.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqQueueType">
            <summary>
            The EAcqQueueType is used to select queue type to be flushed using <c>J_DataStream_FlushQueue()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqQueueType.INPUT_TO_OUTPUT">
            <summary>
            Flush queue of frames, waiting for new data through the acquisition engine to the output queue
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqQueueType.OUTPUT_DISCARD">
            <summary>
            Flush queue of frames, containing new data, waiting to be delivered
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStartFlags">
            <summary>
            The EAcqStartFlags are used to control the start of image acquisition using <c>J_DataStream_StartAcquisition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStartFlags.DEFAULT">
            <summary>
            No flags
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStartFlags.NEXT_IMAGE">
            <summary>
            Deliver the image acquired after the image delivered last
            
            Missed images only happen if the acquisition queue is empty and therefore no buffers available
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStartFlags.LAST_IMAGE">
            <summary>
            Deliver the last complete image acquired
            
            This means that between the image delivered last and the image delivered next can be a number of missed images
            Missed images happen if one processing cycle takes to long
            The positive effect is that the acquired image is not out of the loop but max one image behind
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStartFlags.NEW_IMAGE">
            <summary>
            Deliver the new image acquired while the wait for buffer function is called
            
            The positive effect is that the acquired image is not out of the loop
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStopFlags">
            <summary>
            The EAcqStopFlags are used to control the stop of image acquisition using <c>J_DataStream_StopAcquisition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStopFlags.NONE">
            <summary>
            No stop flags
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EAcqStopFlags.KILL">
            <summary>
            Kill ongoing acquisition instead of waiting for the next image
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd">
            <summary>
            The EBufferInfoCmd is used to get buffer information using <c>J_DataStream_GetBufferInfo()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.BASE">
            <summary>
            Base address of delivered buffer (void *)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.SIZE">
            <summary>
            Size in Bytes (size_t)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.USER_PTR">
            <summary>
            Private Pointer (void *)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.TIMESTAMP">
            <summary>
            Timestamp (uint64_t)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.NEW_DATA">
            <summary>
            Flag if Buffer contains new data since it was queued
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.ISQUEUED">
            <summary>
            Is the buffer queued?
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.IS_ACQUIRING">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.IS_INCOMPLETE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.TLTYPE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.SIZE_FILLED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.WIDTH">
            <summary>
            Width from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.HEIGHT">
            <summary>
            Height from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.XOFFSET">
            <summary>
            X Offset from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.YOFFSET">
            <summary>
            Y Offset from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.XPADDING">
            <summary>
            XPadding from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.YPADDING">
            <summary>
            YPadding from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.FRAMEID">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.IMAGEPRESENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.IMAGEOFFSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.PAYLOADTYPE">
            <summary>
            Payload Type from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.PIXELFORMAT">
            <summary>
            Pixel Type from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.PIXELTYPE">
            <summary>
            Pixel Type from GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.PIXELFORMAT_NAMESPACE">
            <summary>
            Number of packets missing in the frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.DELIVERED_IMAGEHEIGHT">
            <summary>
            Number of packets missing in the frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.DELIVERED_CHUNKPAYLOADSIZE">
            <summary>
            Number of packets missing in the frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.CHUNKLAYOUTID">
            <summary>
            Number of packets missing in the frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.FILENAME">
            <summary>
            Number of packets missing in the frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.BUFFER_INFO_CUSTOM_ID">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.NUM_PACKETS_MISSING">
            <summary>
            Number of packets missing in the frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.BLOCK_ID">
            <summary>
            GigE Vision Stream Protocol Block-ID
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EBufferInfoCmd.NUMBER">
            <summary>
            Buffer Number as announced (uint64_t)
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct">
            <summary>
            This structure is used for reading buffer information with <c>J_DataStream_GetBufferInfo()</c>
            
            Depending on which buffer information has been requested, different fields has to be read in order to interpret the answer correctly
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.Base">
            <summary>
            Frame Data Base address read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.BASE)</c> 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.Size">
            <summary>
            Size in bytes read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.SIZE)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.UserPointer">
            <summary>
            User pointer read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.USER_PTR)</c> 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.TimeStamp">
            <summary>
            Timestamp read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.TIMESTAMP)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.BufferNumber">
            <summary>
            Buffer Number as announced read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.NUMBER)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.NewData">
            <summary>
            Flag indicating new data in buffer since it was queued read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.NEW_DATA)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.IsQueued">
            <summary>
            Flag indication if the buffer is queued read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.ISQUEUED)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.PayloadType">
            <summary>
            Payload Type from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.PAYLOADTYPE)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.PixelFormat">
            <summary>
            Pixel Type from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.PIXELTYPE)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.Width">
            <summary>
            Width from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.WIDTH)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.Height">
            <summary>
            Height from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.HEIGHT)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.XOffset">
            <summary>
            X Offset from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.XOFFSET)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.YOffset">
            <summary>
            Y Offset from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.YOFFSET)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.XPadding">
            <summary>
            X Padding from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.XPADDING)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.YPadding">
            <summary>
            Y Padding from GigE Vision Stream Protocol read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.YPADDING)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.MissingPackets">
            <summary>
            Number of packets missing in the frame read with <c>J_DataStream_GetBufferInfo(EBufferInfoCmd.NUM_PACKETS_MISSING)</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.AwaitDelivery">
            <summary>
            Number of packets Awaiting Delivery from the driver
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.BufferInfoStruct.BlockId">
            <summary>
            Block-ID from the GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd">
            <summary>
            The EStreamInfoCmd is used to get acquisition information using <c>J_DataStream_GetStreamInfo()</c> or <c>J_Image_GetStreamInfo()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NUMBER_OF_FRAMES_DELIVERED">
            <summary>
            This command inquire the number of acquired frames since the last acquisition start.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NUMBER_OF_FRAMES_ANNOUNCED">
            <summary>
            This command inquire the number of frame buffers that have been announced to the acquisition engine using \c J_DataStream_AnnounceBuffer(). This will be the maximum number of frame buffers in the system at any point in time.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NUMBER_OF_FRAMES_QUEUED">
            <summary>
            This command inquire the number of frame buffers available and ready for image acquisition. When a new frame is acquired then it will be moved from this queue into the delivery queue and this value will be decreased by 1. The application can return the frame buffer to this queue using \c J_DataStream_QueueBuffer() after handling the new image delivery.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NUMBER_OF_FRAMES_AWAIT_DELIVERY">
            <summary>
            This command inquire the number of frames that have been put into the delivery queue and are ready to be read and processed by the application. When the application gets the image using \c J_Event_GetData() then the frame buffer will automatically be removed from this delivery queue and the application then have to manually call \c J_DataStream_QueueBuffer() to return the buffer to the acquisition queue again.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.ISGRABBING">
            <summary>
            Inquire if the acquisition engine is running or not.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.CUSTOM_INFO">
            <summary>
            
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NUMBER_OF_FRAMES_LOST_QUEUE_UNDERRUN">
            <summary>
            This command inquire the number of lost frames due to a queue under-run. If the application is not emptying the acquisition queue as fast as the queue gets filled then the newly acquired frames will be dropped and this value will be increased by 1.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EStreamInfoCmd.NUMBER_OF_FRAMES_CORRUPT_ON_DELIEVRY">
            <summary>
            This command inquire the number of frames which have been added to the delivery queue despite the fact that they are missing one or more packets. This will only happen if the \c STREAM_PARAM_CMD_PASS_CORRUPT_FRAMES parameter has been set to true using \c J_DataStream_SetStreamParam().
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct">
            <summary>
            This structure is used for reading buffer information with <c>J_DataStream_GetStreamInfo()</c> or <c>J_Image_GetStreamInfo()</c>
            
            Depending on which buffer information has been requested, different fields has to be read in order to interpret the answer correctly
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.IsGrabbing">
            <summary>
            Is the acquisition engine running?
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.NumOfFramesDelivered">
            <summary>
            This is the number of acquired frames since the last acquisition start.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.NumOfFramesLostQueueUnderrun">
            <summary>
            This is the number of lost frames due to a queue under-run. If the application is not emptying the acquisition queue as fast as the queue gets filled then the newly acquired frames will be dropped and this value will be increased by 1.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.NumOfBuffersAnnounced">
            <summary>
            This is the number of frame buffers that have been announced to the acquisition engine using \c J_DataStream_AnnounceBuffer(). This will be the maximum number of frame buffers in the system at any point in time.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.NumOfFramesQueued">
            <summary>
            This is the number of frame buffers available and ready for image acquisition. When a new frame is acquired then it will be moved from this queue into the delivery queue and this value will be decreased by 1. The application can return the frame buffer to this queue using \c J_DataStream_QueueBuffer() after handling the new image delivery.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.NumOfFramesAwaitingDelivery">
            <summary>
            This is the number of frames that have been put into the delivery queue and are ready to be read and processed by the application. When the application gets the image using \c J_Event_GetData() then the frame buffer will automatically be removed from this delivery queue and the application then have to manually call \c J_DataStream_QueueBuffer() to return the buffer to the acquisition queue again.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamInfoStruct.NumOfFramesCorruptOnDelivery">
            <summary>
            This is the number of frames which have been added to the delivery queue despite the fact that they are missing one or more packets. This will only happen if the \c STREAM_PARAM_CMD_PASS_CORRUPT_FRAMES parameter has been set to true using \c J_DataStream_SetStreamParam().
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd">
            <summary>
            The EDataStreamParamCmd is used to get/set acquisition information using <c>J_DataStream_GetParam()</c> and <c>J_DataStream_GetParam()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.CanResend">
            <summary>
            Get / Set Flag indicating if the source can handle resends. !=0: Enable resends(default), =0: Disable resends
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.NumberOfBytesPerFrame">
            <summary>
            Get / Set Total Number of bytes per frame 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.PassCorruptFrames">
            <summary>
            Get / Set Flag indicating if corrupt frames are passed to the layer above. !=0: Enable, =0: Disable
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.MaxFramesInNotCompletedList">
            <summary>
            Get / Set Max number of frames in not complete list
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.RxTimeoutsBeforeListFlush">
            <summary>
            Get / Set Number of receive timeouts before incomplete list is flushed / delivered
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.OutOfOrderPacketsBeforeResend">
            <summary>
            Get / Set Out of order Packets before resend is issued
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDataStreamParamCmd.RxTimeout">
            <summary>
            Get / Set Timeout in ms for receive
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct">
            <summary>
            This structure is used to get/set acquisition information using <c>J_DataStream_GetParam()</c> and <c>J_DataStream_GetParam()</c>
            
            Depending on which buffer information has been requested, different fields has to be read in order to interpret the answer correctly
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.CanResend">
            <summary>
            Flag indicating if the source can handle resends. !=0: Enable resends(default), =0: Disable resends
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.NumberOfBytesPerFrame">
            <summary>
            Total Number of bytes per frame
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.PassCorruptFrames">
            <summary>
            Flag indicating if corrupt frames are passed to the layer above. !=0: Enable, =0: Disable
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.MaxFramesInNotCompletedList">
            <summary>
            Max number of frames in not complete list
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.RxTimeoutsBeforeListFlush">
            <summary>
            Number of receive timeouts before incomplete list is flushed / delivered
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.OutOfOrderPacketsBeforeResend">
            <summary>
            Out of order Packets before resend is issued
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.StreamParameterStruct.RxTimeout">
            <summary>
            Timeout in ms for receive
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EEventInfoID">
            <summary>
            The EEventInfoID is used to obtain information about the number of entries in the queue using <c>J_Event_GetInfo()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EEventInfoID.NUM_ENTRYS_IN_QUEUE">
            <summary>
            Number of entries in queue
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EventInfoData">
            <summary>
            Struct containing the information provided by a GigE Event to pass it on to the GenAPI
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EventInfoData.NumEntriesInQueue">
            <summary>
            Number of events in queue.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType">
            <summary>
            The EDeviceEventType is used to specify which type of event to register with the Transport Layer
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType.NEW_BUFFER">
            <summary>
            New buffer ready. NEW_BUFFER_BufferHandle will hold Buffer Handle
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType.GEV_EVENT_CMD">
            <summary>
            Event command received
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType.GEV_EVENTDATA_CMD">
            <summary>
            Event data command received
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType.ERROR">
            <summary>
            Error
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType.CONNECTION">
            <summary>
            Camera Connection status
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceEventType.MAX_ID">
            <summary>
            
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceConnectionType">
            <summary>
            The EDeviceConnectionType is used to report changes in connection state
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceConnectionType.Connected">
            <summary>
            Camera is connected
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceConnectionType.Disconnected">
            <summary>
            Camera is disconnected
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceConnectionType.LostControl">
            <summary>
            The camera timed out internally and we lost control access. We cannot control the camera before re-acquiring control again
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData">
            <summary>
            Struct containing the information provided by a GigE Event to pass it on to the GenAPI
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.GEV_EVENT_CMD_EventID">
            <summary>
            EVENT identifying reason.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.GEV_EVENT_CMD_StreamChannelIndex">
            <summary>
            Index of stream channel (0xFFFF for no channel).
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.GEV_EVENT_CMD_BlockID">
            <summary>
            Data block ID (0 for no block).
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.GEV_EVENT_CMD_Timestamp">
            <summary>
            Event timestamp (0 if not supported).
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.GEV_EVENT_CMD_EventDataLength">
            <summary>
            Number of additional data associated with the event
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.GEV_EVENT_CMD_EventData">
            <summary>
            The additional data associated with the event
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.NEW_BUFFER_BufferHandle">
            <summary>
            Buffer handle of the delivered buffer
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.DeviceEventData.CONNECTION_Status">
            <summary>
            Current status for the camera connection
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult">
            <summary>
            The ECondWaitResult is wait result type returned in <c>J_Event_WaitForCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitTimeout">
            <summary>
            <c>J_Event_WaitForCondition()</c> timed out
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal">
            <summary>
            <c>J_Event_WaitForCondition()</c> got signaled using <c>J_Event_SignalCondition()</c> or <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 0 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit">
            <summary>
            <c>J_Event_WaitForCondition()</c> got signaled using <c>J_Event_ExitCondition()</c> or <c>J_Event_WaitForCondition()</c> got signaled on Condition 0 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal1">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 1 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit1">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 1 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal2">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 2 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit2">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 2 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal3" -->
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit3">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 3 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal4">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 4 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit5">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 5 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal6">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 6 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit6">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 6 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal7">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 7 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit7">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 7 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal8">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 8 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit8">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 8 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitSignal9">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 9 using <c>J_Event_SignalCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitExit9">
            <summary>
            <c>J_Event_WaitForMultipleConditions()</c> got signaled on Condition 9 using <c>J_Event_ExitCondition()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ECondWaitResult.WaitError">
            <summary>
            Error in <c>J_Event_WaitForCondition()</c> or <c>J_Event_WaitForMultipleConditions()</c>
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.NodeChangeDelegate">
            <summary>
            Delegate to be called whenever the value or any of the node properties changes
            </summary>
            <param name="NodeHandle">A handle to the GenICam node that has changed value or changed property values</param>
            <returns>bool</returns>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.POINT">
            <summary>
            Windows <c>POINT</c> implementation for pInvoke
            
            This structure makes it possible to call an unmanaged function that is having a standard C/C++ <c>POINT</c> structure as parameter
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.POINT.X">
            <summary>
            X position
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.POINT.Y">
            <summary>
            Y position
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.POINT.#ctor(System.Int32,System.Int32)">
            <summary>
            POINT Constructor
            </summary>
            <param name="x">X position</param>
            <param name="y">Y position</param>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.POINT.op_Implicit(Jai_FactoryDotNET.Jai_FactoryWrapper.POINT)~System.Drawing.Point">
            <summary>
            Implicit assignment operator
            </summary>
            <param name="p">POINT structure to be converted to System.Drawing.Point</param>
            <returns>System.Drawing.Point</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.POINT.op_Implicit(System.Drawing.Point)~Jai_FactoryDotNET.Jai_FactoryWrapper.POINT">
            <summary>
            Implicit assignment operator
            </summary>
            <param name="p">System.Drawing.Point to be converted to POINT structure</param>
            <returns>POINT</returns>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE">
            <summary>
            Windows <c>SIZE</c> implementation for pInvoke
            
            This structure makes it possible to call an unmanaged function that is having a standard C/C++ <c>SIZE</c> structure as parameter
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE.cx">
            <summary>
            Width
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE.cy">
            <summary>
            Height
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="cx">Width</param>
            <param name="cy">Height</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT">
            <summary>
            Windows <c>RECT</c> implementation for pInvoke
            
            This structure makes it possible to call an unmanaged function that is having a standard C/C++ <c>RECT</c> structure as parameter
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Top">
            <summary>
            Top
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Bottom">
            <summary>
            Bottom
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="left_">Left</param>
            <param name="top_">Top</param>
            <param name="right_">Right</param>
            <param name="bottom_">Bottom</param>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.ToRectangle">
            <summary>
            Handy method for converting to a System.Drawing.Rectangle
            </summary>
            <returns>System.Drawing.Rectangle</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.FromRectangle(System.Drawing.Rectangle)">
            <summary>
            Handy method for converting from a System.Drawing.Rectangle
            </summary>
            <param name="rectangle">System.Drawing.Rectangle to be converted from</param>
            <returns>RECT</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.GetHashCode">
            <summary>
            Return Hash code for the RECT
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.op_Implicit(Jai_FactoryDotNET.Jai_FactoryWrapper.RECT)~System.Drawing.Rectangle">
            <summary>
            Implicit assignment operator from RECT to Rectangle
            </summary>
            <param name="rect">RECT to be assigned to a Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.op_Implicit(System.Drawing.Rectangle)~Jai_FactoryDotNET.Jai_FactoryWrapper.RECT">
            <summary>
            Implicit assignment operator from Rectangle to RECT
            </summary>
            <param name="rect">Rectangle to be assigned to a RECT</param>
            <returns></returns>
        </member>
        <member name="P:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Height">
            <summary>
            Height of the rectangle
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Width">
            <summary>
            Width of the rectangle
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Size">
            <summary>
            Size of the rectangle
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.Jai_FactoryWrapper.RECT.Location">
            <summary>
            Location of the rectangle
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelTypeColorInfo">
            <summary>
            Color information for the <c>EPixelType</c> enumeration. To get the Color information call <c>GetPixelTypeColorInfo()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelTypeColorInfo.Monochrome">
            <summary>
            Monochrome pixel value format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelTypeColorInfo.RGB">
            <summary>
            RGB color pixel value format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelTypeColorInfo.Custom">
            <summary>
            Custom pixel value format
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType">
            <summary>
            Pixel Types used by the camera and in the buffer information structure <c>ImageInfo</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO8">
            <summary>
            Mono 8 bit (Mono8=0x01080001)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO8_SIGNED">
            <summary>
            Mono 8 bit signed (Mono8Signed=0x01080002)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO10">
            <summary>
            Mono 10 bit (Mono10=0x01100003)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO10_PACKED">
            <summary>
            Mono 10 bit packed (Mono10Packed=0x010C0004)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO12">
            <summary>
            Mono 12 bit (Mono12=0x01100005)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO12_PACKED">
            <summary>
            Mono 12 bit packed (Mono12Packed=0x010C0006)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO14">
            <summary>
            Mono 14 bit packed (Mono14=0x01100025)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_MONO16">
            <summary>
            Mono 16 bit (Mono16=0x01100007)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGR8">
            <summary>
            Bayer GR 8 bit (BayerGR8=0x01080008)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYRG8">
            <summary>
            Bayer RG 8 bit (BayerRG8=0x01080009)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGB8">
            <summary>
            Bayer GB 8 bit (BayerGB8=0x0108000A)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYBG8">
            <summary>
            Bayer BG 8 bit (BayerBG8=0x0108000B)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGR10">
            <summary>
            Bayer GR 10 bit (BayerGR10=0x0110000C)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYRG10">
            <summary>
            Bayer RG 10 bit (BayerRG10=0x0110000D)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGB10">
            <summary>
            Bayer GB 10 bit (BayerGB10=0x0110000E)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYBG10">
            <summary>
            Bayer BG 10 bit (BayerBG10=0x0110000F)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGR12">
            <summary>
            Bayer GR 12 bit (BayerGR12=0x01100010)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYRG12">
            <summary>
            Bayer RG 12 bit (BayerRG12=0x01100011)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGB12">
            <summary>
            Bayer GB 12 bit (BayerGB12=0x01100012)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYBG12">
            <summary>
            Bayer BG 12 bit (BayerBG12=0x01100013)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGR10_PACKED">
            <summary>
            Bayer GR 10 bit packed (BayerGR10Packed=0x010C0026)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYRG10_PACKED">
            <summary>
            Bayer RG 10 bit packed (BayerRG10Packed=0x010C0027)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGB10_PACKED">
            <summary>
            Bayer GB 10 bit packed (BayerGB10Packed=0x010C0028)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYBG10_PACKED">
            <summary>
            Bayer BG 10 bit packed (BayerBG10Packed=0x010C0029)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGR12_PACKED">
            <summary>
            Bayer GR 12 bit packed (BayerGR12Packed=0x010C002A) 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYRG12_PACKED">
            <summary>
            Bayer RG 12 bit packed (BayerRG12Packed=0x010C002B) 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGB12_PACKED">
            <summary>
            Bayer GB 12 bit packed (BayerGB12Packed=0x010C002C) 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYBG12_PACKED">
            <summary>
            Bayer BG 12 bit packed (BayerBG12Packed=0x010C002D) 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGR16">
            <summary>
            Bayer GR 16 bit (BayerGR16=0x0110002E)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYRG16">
            <summary>
            Bayer RG 16 bit (BayerRG16=0x0110002F) 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYGB16">
            <summary>
            Bayer GB 16 bit (BayerGB16=0x01100030) 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BAYBG16">
            <summary>
            Bayer BG 16 bit (BayerBG16=0x01100031)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB8_PACKED">
            <summary>
            RGB 8 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BGR8_PACKED">
            <summary>
            BGR 8 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGBA8_PACKED">
            <summary>
            RGBA 8 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BGRA8_PACKED">
            <summary>
            BGRA 8 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB10_PACKED">
            <summary>
            RGB 10 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BGR10_PACKED">
            <summary>
            BGR 10 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB12_PACKED">
            <summary>
            RGB 12 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BGR12_PACKED">
            <summary>
            BGR 12 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB16_PACKED">
            <summary>
            RGB 16 bit packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB10V1_PACKED">
            <summary>
            RGB 10 bit version 1 packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB10V2_PACKED">
            <summary>
            RGB 10 bit version 2 packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB12V1_PACKED">
            <summary>
            RGB 12 bit version 1 packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_YUV411_PACKED">
            <summary>
            YUV 4.1.1 packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_YUV422_PACKED">
            <summary>
            YUV 4.2.2 packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_YUV444_PACKED">
            <summary>
            YUV 4.4.4 packed
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB8_PLANAR">
            <summary>
            RGB 8 bit planar
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB10_PLANAR">
            <summary>
            RGB 10 bit planar
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB12_PLANAR">
            <summary>
            RGB 12 bit planar
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_RGB16_PLANAR">
            <summary>
            RGB 16 bit planar
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EPixelFormatType.GVSP_PIX_BGR16_PACKED_INTERNAL">
            <summary>
            RGB 16 bit per color used internally 
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo">
            <summary>
            Image information structure used in callback and image conversion functions
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.PixelFormat">
            <summary>
            Pixel Format Type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.SizeX">
            <summary>
            Image width
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.SizeY">
            <summary>
            Image height
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.ImageSize">
            <summary>
            Number of bytes for image
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.ImageBuffer">
            <summary>
            Buffer pointer. This is a handle to the buffer used in <c>J_Image_GetBufferInfo()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.TimeStamp">
            <summary>
            Timestamp from camera
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.MissingPackets">
            <summary>
            Number of missing packets
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.AnnouncedBuffers">
            <summary>
            Number of announced buffers
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.QueuedBuffers">
            <summary>
            Number of queued buffers
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.OffsetX">
            <summary>
            Image X-offset (in case of ROI)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.OffsetY">
            <summary>
            Image Y-offset (in case of ROI)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.AwaitDelivery">
            <summary>
            Number of frames awaiting delivery from the driver
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo.BlockID">
            <summary>
            Block-ID for the GigE Vision Stream Protocol
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue">
             <summary>
             Pixel value structure that will hold Mono8, Mono10, Mono12, Mono16, DIB24, RGB24, DIB32 and BGR48 pixels. 
             
             Which values to read and write will depend on the <c>PixelType</c> value of the <c>ImageInfo</c> structure.
             
             
             <TABLE>
             <CAPTION>Monochrome buffer format</CAPTION>
             <TR><TD>PixelType</TD><TD>PixelValue element</TD></TR>
             <TR><TD>GVSP_PIX_MONO8</TD><TD>MONO8_Y</TD></TR>
             <TR><TD>GVSP_PIX_MONO10</TD><TD>MONO10_Y</TD></TR>
             <TR><TD>GVSP_PIX_MONO10_PACKED</TD><TD>MONO10_Y</TD></TR>
             <TR><TD>GVSP_PIX_MONO12</TD><TD>MONO12_Y</TD></TR>
             <TR><TD>GVSP_PIX_MONO12_PACKED</TD><TD>MONO12_Y</TD></TR>
             <TR><TD>GVSP_PIX_MONO16</TD><TD>MONO16_Y</TD></TR>
             </TABLE>
             
             <TABLE>
             <CAPTION>Bayer buffer format</CAPTION>
             <TR><TD>PixelType</TD><TD>PixelValue element</TD></TR>
             <TR><TD>GVSP_PIX_BAYGR8</TD><TD>RGB24_B</TD></TR>
             <TR><TD>GVSP_PIX_BAYRG8</TD><TD>RGB24_B</TD></TR>
             <TR><TD>GVSP_PIX_BAYGB8</TD><TD>RGB24_B</TD></TR>
             <TR><TD>GVSP_PIX_BAYBG8</TD><TD>RGB24_B</TD></TR>
             <TR><TD>GVSP_PIX_BAYGR10</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYRG10</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYGB10</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYBG10</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYGR12</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYRG12</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYGB12</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BAYBG12</TD><TD>BGR48_x</TD></TR>
             </TABLE>
             
             <TABLE>
             <CAPTION>RGB Packed buffer format defines</CAPTION>
             <TR><TD>PixelType</TD><TD>PixelValue element</TD></TR>
             <TR><TD>GVSP_PIX_RGB8_PACKED</TD><TD>RGB24_x</TD></TR>
             <TR><TD>GVSP_PIX_BGR8_PACKED</TD><TD>RGB24_x</TD></TR>
             <TR><TD>GVSP_PIX_RGBA8_PACKED</TD><TD>ARGB32_x</TD></TR>
             <TR><TD>GVSP_PIX_BGRA8_PACKED</TD><TD>ARGB32_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB10_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BGR10_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB12_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_BGR12_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB10V1_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB10V2_PACKED</TD><TD>BGR48_x</TD></TR>
             </TABLE>
             
             <TABLE>
             <CAPTION>YUV Packed buffer format</CAPTION>
             <TR><TD>PixelType</TD><TD>PixelValue element</TD></TR>
             <TR><TD>GVSP_PIX_YUV411_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_YUV422_PACKED</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_YUV444_PACKED</TD><TD>BGR48_x</TD></TR>
             </TABLE>
            
             <TABLE>
             <CAPTION>RGB Planar buffer format</CAPTION>
             <TR><TD>PixelType</TD><TD>PixelValue element</TD></TR>
             <TR><TD>GVSP_PIX_RGB8_PLANAR</TD><TD>BGR24_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB10_PLANAR</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB12_PLANAR</TD><TD>BGR48_x</TD></TR>
             <TR><TD>GVSP_PIX_RGB16_PLANAR</TD><TD>BGR48_x</TD></TR>
             </TABLE>
            
             Internal use only
             
             GVSP_PIX_BGR16_PACKED_INTERNAL -> BGR48_x
             
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.MONO8_Y">
            <summary>
            Luminance in Mono8 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.MONO10_Y">
            <summary>
            Luminance in Mono10 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.MONO12_Y">
            <summary>
            Luminance in Mono12 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.MONO16_Y">
            <summary>
            Luminance in Mono16 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.DIB24_B">
            <summary>
            Blue in DIB24 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.DIB24_G">
            <summary>
            Green in DIB24 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.DIB24_R">
            <summary>
            Red in DIB24 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.RGB24_B">
            <summary>
            Blue in RGB24 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.RGB24_G">
            <summary>
            Green in RGB24 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.RGB24_R">
            <summary>
            Red in RGB24 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.ARGB32_B">
            <summary>
            Blue in ARGB32 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.ARGB32_G">
            <summary>
            Green in ARGB32 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.ARGB32_R">
            <summary>
            Red in ARGB32 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.ARGB32_A">
            <summary>
            Alpha in ARGB32 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.BGR48_B">
            <summary>
            Blue in BGR48 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.BGR48_G">
            <summary>
            Green in BGR48 format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.PixelValue.BGR48_R">
            <summary>
            Red in BGR48 format
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWWindowType">
            <summary>
            Window type used in <c>J_Image_OpenViewWindowEx()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWWindowType.Overlapped">
            <summary>
            Overlapped window
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWWindowType.Child">
            <summary>
            Child window
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWWindowType.ChildStretch">
            <summary>
            Stretched child window
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWWindowType.OverlappedStretch">
            <summary>
            Stretched overlapped window
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType">
            <summary>
            View Window option types used in <c>J_Image_SetViewWindowOption()</c> and <c>J_Image_GetViewWindowOption()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType.MouseZoom">
            <summary>
            Enable/Disable the mouse zoom feature using <c>J_Image_SetViewWindowOption()</c>. The <c>Option</c> parameter is a reference to a boolean value
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType.MouseCursor">
            <summary>
            Enable/Disable the mouse cursor using <c>J_Image_SetViewWindowOption()</c>. The <c>Option</c> parameter is a reference to a boolean value
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType.CallbackMask">
            <summary>
            Select which of the callback events to enable using <c>J_Image_SetViewWindowOption()</c>. The <c>Option</c> parameter is a reference to a uint32 value and the value is a bitmask created by OR'ing the <c>J_IVW_CALLBACK_TYPE</c> enumeration values
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWOptionType.DoubleBuffering">
            <summary>
            Enable/Disable the double-buffering using <c>J_Image_SetViewWindowOption()</c>. The <c>Option</c> parameter is a reference to a boolean value
            This will remove any View Window overlay flickering but it will be slightly slower than without double-buffering.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWOptionValue">
            <summary>
            Option type used in <c>J_Image_SetViewWindowOption()</c> and <c>J_Image_GetViewWindowOption()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWOptionValue.BooleanValue">
            <summary>
            Image View Window Option value of type Boolean
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWOptionValue.UInt32Value">
            <summary>
            Image View Window Option value of type UInt32. This is used for the <c>EIVWOptionType.CallbackMask</c> option
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType">
            <summary>
            Image View Window Callback type. This type determines how to interprete the data passed in by the callback value parameter. 
            It is also used when the callback mask is set as a View Window option.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_WINDOW_MOVE">
            <summary>
            The View Window has been moved. The Value pointer in the callback function points to a POINT structure
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_WINDOW_SIZE">
            <summary>
            The View Window has been resized. The Value pointer in the callback function points to a SIZE structure
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_MOUSE_MOVE">
            <summary>
            The mouse has been moved inside the View Window. The Value pointer in the callback function points to a POINT structure. 
            The location is in image pixel coordinates
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_MOUSE_LBUTTON_DOWN">
            <summary>
            The left mouse button has been clicked inside the View Window. The Value pointer in the callback function points to a 
            POINT structure. The location is in image pixel coordinates
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_MOUSE_LBUTTON_UP">
            <summary>
            The left mouse button has been released inside the View Window. The Value pointer in the callback function points to a 
            POINT structure. The location is in image pixel coordinates
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_MOUSE_RBUTTON_DOWN">
            <summary>
            The right mouse button has been clicked inside the View Window. The Value pointer in the callback function points to a 
            POINT structure. The location is in image pixel coordinates
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_MOUSE_RBUTTON_UP">
            <summary>
            The right mouse button has been released inside the View Window. The Value pointer in the callback function points to a 
            POINT structure. The location is in image pixel coordinates
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_ZOOM_POS">
            <summary>
            The Zoom or view location has changed the View Window. The pValue pointer returns the new view position and zoom values 
            in a J_IVW_ZOOM_POS structure
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_AREA_SELECT">
            <summary>
            The user has dragged a selection rectangle using the mouse. The Value pointer returns the selected rectangle in a 
            RECT structure. The location is in image pixel coordinates 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_USER_DRAW_IMAGE">
            <summary>
            The Image View Window is done drawing the image so the user will now be able to draw an image overlay onto the image.
            Be aware the the coordinates used by the drawing methods will be in "image coordinates" so the overlay will be scaled 
            like the rest of the image
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EIVWCallbackType.J_IVW_CB_USER_DRAW_VIEW_WINDOW">
            <summary>
            The Image View Window is done drawing the image into the View Window so the user will now be able to draw an image overlay 
            onto View Window output.
            Be aware the the coordinates used by the drawing methods will be in "View Window coordinates" so the overlay will NOT be scaled 
            even if the image is stretched or shrunk into the View Window
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWCallbackValue">
            <summary>
            Type of value passed on by the Image View Window callback delegate. The value to use depends on the Callback Type.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWCallbackValue.PointValue">
            <summary>
            The Callback value is a POINT
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWCallbackValue.SizeValue">
            <summary>
            The Callback value is a SIZE. This is used for the J_IVW_CB_WINDOW_SIZE callback type 
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWCallbackValue.RectValue">
            <summary>
            The Callback value is a RECT. This is used for the J_IVW_CB_AREA_SELECT callback type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWCallbackValue.ZoomPosValue">
            <summary>
            The Callback value is a ZOOMPOS. This is used for the J_IVW_CB_ZOOM_POS callback type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.IVWCallbackValue.UserDrawInfoValue">
            <summary>
            The Callback value is a User Draw information structure. This is used for the J_IVW_CB_USER_DRAW_IMAGE and
            J_IVW_CB_USER_DRAW_VIEW_WINDOW callback types
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ZoomPos">
            <summary>
            Zoom Position value structure. This is used by the <c>J_IVW_CB_ZOOM_POS</c> Image View Window event
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ZoomPos.Offset">
            <summary>
            Offset like passed into <c>J_Image_SetImageOffset()</c> and <c>J_Image_SetImageOffsetEx()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ZoomPos.ZoomRatioX">
            <summary>
            Zoom ratio in X-direction: 100.0=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ZoomPos.ZoomRatioY">
            <summary>
            Zoom ratio in Y-direction: 100.0=The original image is reduced to the window size. 1=1/100 of the original images is expanded to the window size.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.UserDrawInfo">
            <summary>
            User-Draw value structure. This is used by the <c>J_IVW_CB_USER_DRAW_IMAGE</c> and <c>J_IVW_CB_USER_DRAW_VIEW_WINDOW</c> Image View Window event
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UserDrawInfo.hDeviceContext">
            <summary>
            Handle to the DeviceContext to be used when drawing the image overlay
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UserDrawInfo.Width">
            <summary>
            Width of the User Draw area
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UserDrawInfo.Height">
            <summary>
            Height of the User Draw area
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm">
            <summary>
            Bayer color interpolation algorithm
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerStandard">
            <summary>
            Standard 3x3 Bayer algorithm
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerStandardMultiprocessor">
            <summary>
            Standard 3x3 Bayer algorithm (Enables parallel-processing with multi-processor/core)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerExtended">
            <summary>
            Extended 3x3 Bayer algorithm based on smallest gradient. This enhances horizontal and vertical lines and avoids "zipper-effect"
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerExtendedMultiprocessor">
            <summary>
            Extended 3x3 Bayer algorithm based on smallest gradient. This enhances horizontal and vertical lines and avoids "zipper-effect". (Enables parallel-processing with multi-processor/core)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerSimple">
            <summary>
            Simple Bayer algorithm that improves processing speed over the "Standard 3x3 Bayer Algorithm" but sacrifices the image quality. Instead of averaging neighbour pixels this algorithm will simply copy values instead.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerSimpleMultiprocessor">
            <summary>
            Simple Bayer algorithm that improves processing speed over the "Standard 3x3 Bayer Algorithm" but sacrifices the image quality. Instead of averaging neighbour pixels this algorithm will simply copy values instead. (Enables parallel-processing with multi-processor/core)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerFast">
            <summary>
            Very fast Bayer algorithm that sacrifices the image quality as well as halving both the horizontal and vertical resolution. This can be used in application that only display the images and where the speed is most important.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorInterpolationAlgorithm.BayerFastMultiprocessor">
            <summary>
            Very fast Bayer algorithm that sacrifices the image quality as well as halving both the horizontal and vertical resolution. (Enables parallel-processing with multi-processor/core). This can be used in application that only display the images and where the speed is most important.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat">
            <summary>
            Image conversion pixelformat options used in <c>J_Image_ConvertImage()</c> and <c>J_Image_Malloc()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormatNone">
            <summary>
            This is only used in <c>J_Image_Malloc()</c> to allocate an image with identical size and pixel format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat24BitSwapRB">
            <summary>
            Swaps the data of R and B. (24bit)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat8BitY">
            <summary>
            Converts from RGB(24/48bit) to Y(8bit).
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat24BitUYV">
            <summary>
            Converts from RGB(24/48bit) to UYV. Not supported yet
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat24BitYCBCR">
            <summary>
            Converts from RGB(24/48bit) to YCBCR. Not supported yet
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat48BitSwapRB">
            <summary>
            Swaps the data of R and B. (48bit)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat16BitY">
            <summary>
            Converts from RGB(24/48bit) to Y(16bit).
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormatSwapRB">
            <summary>
            Swaps the data of R and B. Selects the bit-length automatically. (24bit->24bit, 48bit->48bit)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormatY">
            <summary>
            Converts from RGB(24/48bit) to Y(8bit). Selects the bit-length automatically. (24bit->24bit, 48bit->48bit)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat3YH">
            <summary>
            Convert RGB (24-bit RGB/24-bit BGR/30-bit RGB Packed V1/30-bit RGB Packed V2) into 3xY images stitched together horizontally (3-head camera special feature!)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EColorConversionPixelFormat.PixelFormat3YV">
            <summary>
            Convert RGB (24-bit RGB/24-bit BGR/30-bit RGB Packed V1/30-bit RGB Packed V2) into 3xY images stitched together vertically (3-head camera special feature!)
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ImageViewWindowCallBack">
            <summary>
            Delegate to be called as callback function when a View Window event has been detected
            </summary>
            <param name="WindowHandle">Image information to be used in the image function</param>
            <param name="Type">Type of View Window Event</param>
            <param name="CallbackValue">View Window Event value</param>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat">
            <summary>
            File type used in <c>J_Image_SaveFileEx()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat.Tiff">
            <summary>
            Uncompressed Tiff file format
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat.Jpeg">
            <summary>
            Jpeg file format. When this format is selected then the EncoderParameter should be used in <c>J_Image_SaveFileEx()</c>.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat.Bmp">
            <summary>
            BMP file format.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat.Jai">
            <summary>
            Proprietary RAW file format that includes the RAW pixel data as well as additional image informations.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat.RAW">
            <summary>
            RAW file format that only contains the pixel data. This is identical to using the <c>J_Image_SaveFileRaw()</c> function
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo">
            <summary>
            Structure containing LUT data.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo.LUTEntries">
            <summary>
            Number of LUT entries allocated. This will depend on the pixel depth!
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo.PixelDepth">
            <summary>
            Pixel depth! This can be 8-bit, 10-bit, 12-bit, 14-bit or 16-bit.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo.Colors">
            <summary>
            Number of colors. This is either 1 (monochrome) or 3 for Bayer and RGB
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo.LutR">
            <summary>
            Pointer to the actual LUT data for color 1 (Monochrome or Red channel)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo.LutG">
            <summary>
            Pointer to the actual LUT data for color 2 (Green channel)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.LUTInfo.LutB">
            <summary>
            Pointer to the actual LUT data for color 3 (Blue channel)
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo">
            <summary>
            Structure containing Histogram data.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo.HistEntries">
            <summary>
            Number of Histogram entries allocated. This will depend on the pixel depth!
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo.PixelDepth">
            <summary>
            Pixel depth! This can be 8-bit, 10-bit, 12-bit, 14-bit or 16-bit.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo.Colors">
            <summary>
            Number of colors. This is either 1 (monochrome) or 3 for Bayer and RGB
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo.HistR">
            <summary>
            Pointer to the actual Histogram data for color 1 (Monochrome or Red channel)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo.HistG">
            <summary>
            Pointer to the actual Histogram data for color 2 (Green channel)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.HistogramInfo.HistB">
            <summary>
            Pointer to the actual Histogram data for color 3 (Blue channel)
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EFlipType">
            <summary>
            Flip type used in <c>J_Image_Flip()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFlipType.FlipHorizontally">
            <summary>
            Flip Horizontally (Mirror)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EFlipType.FlipVertically">
            <summary>
            Flip Vertically.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ERotateType">
            <summary>
            Rotate type used in <c>J_Image_Rotate()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ERotateType.Rotate90DegCw">
            <summary>
            Rotate 90 degree clockwise
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ERotateType.Rotate90DegCcw">
            <summary>
            Rotate 90 degree counter-clockwise
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ERotateType.Rotate180Deg">
            <summary>
            Rotate 180 degree (upside-down)
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType">
            <summary>
            Image Processing algorithm type used in <c>J_Image_Processing()</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.RedCompensation">
            <summary>
            Red-Compensation
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.RedCompensationMulti">
            <summary>
            Red-Compensation using multi-processor
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.GreenCompensation">
            <summary>
            Green-Compensation
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.GreenCompensationMulti">
            <summary>
            Green-Compensation using multi-processor
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.LensDistortion">
            <summary>
            Lens Distortion Correction
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.LensDistortionMulti">
            <summary>
            Lens Distortion Correction using multi-processor
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.LensDistortionMapInit">
            <summary>
            Lens Distortion Correction map creation and initialization. If this function is used then the processing speed of the <c>LensDistortion</c> and <c>LensDistortionMulti</c> will be faster.
            The Lens Distortion Correction map will need to be released after the processing is ended by using <c>LensDistortionMapFree</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EProcessFunctionType.LensDistortionMapFree">
            <summary>
            Lens Distortion Correction map cleanup. If the <c>LensDistortionMapInit</c> function has been used then all allocated resources will be freed using this function.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct">
            <summary>
            Structure containing Color-Compensation parameters. This is used for both Red-Compensation and Green-Compensation.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.RectOfROI">
            <summary>
            Rectangle of a region of interest.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.BThreshold">
            <summary>
            Threshold of blue channel
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.GThreshold">
            <summary>
            Threshold of green channel
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.RThreshold">
            <summary>
            Threshold of red channel
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.BGain">
            <summary>
            Blue gain for compensation. 4096:1.00
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.GGain">
            <summary>
            Green gain for compensation. 4096:1.00
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.ColorCompensationROIStruct.RGain">
            <summary>
            Red gain for compensation. 4096:1.00
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.RedCompensationStruct">
            <summary>
            Structure containing Red-Compensation parameters.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.RedCompensationStruct.NumOfROI">
            <summary>
            Number of ROI for color compensation. This has to be a value between 1 and 10
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.RedCompensationStruct.ColorCompensationROI">
            <summary>
            The 10 Red-Compensation ROIs. The NumOfROI field specified how many of these structures are initialized with data
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.GreenCompensationStruct">
            <summary>
            Structure containing Green-Compensation parameters.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.GreenCompensationStruct.NumOfROI">
            <summary>
            Number of ROI for color compensation. This has to be a value between 1 and 10
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.GreenCompensationStruct.ColorCompensationROI">
            <summary>
            The 10 Green-Compensation ROIs. The NumOfROI field specified how many of these structures are initialized with data
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct">
            <summary>
            Structure containing Lens Distortion Correction parameters.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.OpticalCenterX">
            <summary>
            Optical center X used to model possible displacement from optical axis
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.OpticalCenterY">
            <summary>
            Optical center Y used to model possible displacement from optical axis
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.FocalLengthX">
            <summary>
            Focal length X used for normalizing the lens distortion calculation. This is typically a value close to the Width of the image in pixels
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.FocalLengthY">
            <summary>
            Focal length Y used for normalizing the lens distortion calculation. If the pixels on the imager are square then this is the same as FocalLengthX
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.CoeffK1">
            <summary>
            Radial Distortion coefficient k1 for r^2 in Taylor series expansion around r=0: Xcorr = X(1+k1*r^2+k2*r^4+k3*r^6), Ycorr = Y(1+k1*r^2+k2*r^4+k3*r^6)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.CoeffK2">
            <summary>
            Radial Distortion coefficient k2 for r^2 in Taylor series expansion around r=0: Xcorr = X(1+k1*r^2+k2*r^4+k3*r^6), Ycorr = Y(1+k1*r^2+k2*r^4+k3*r^6)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.CoeffK3">
            <summary>
            Radial Distortion coefficient k3 for r^2 in Taylor series expansion around r=0: Xcorr = X(1+k1*r^2+k2*r^4+k3*r^6), Ycorr = Y(1+k1*r^2+k2*r^4+k3*r^6)
            This value is normally set to 0 unless it is a fish-eye lens
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.CoeffP1">
            <summary>
            Tangential Distortion coefficient p1. Xcorr=X+[2*p1*Y+p2*(r^2+2*X^2)], Ycorr=Y+[p1*(r^2+2*y^2)+2*p2*X]
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.CoeffP2">
            <summary>
            Tangential Distortion coefficient p2. Xcorr=X+[2*p1*Y+p2*(r^2+2*X^2)], Ycorr=Y+[p1*(r^2+2*y^2)+2*p2*X]
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.InterpolationType">
            <summary>
            Lens Distortion Interpolation type
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.UndistortStruct.InternalUndistortMap">
            <summary>
            Pointer to be used internally in the Lens Distortion correction algorithm to speed up the processing. This should not be modified manually!
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.Jai_FactoryWrapper.EInterpolationType">
            <summary>
            Lens Distortion Interpolation type used in <c>UndistortStruct</c>
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EInterpolationType.InterpolationNone">
            <summary>
             No interpolation. Closest pixel is used instead
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.Jai_FactoryWrapper.EInterpolationType.InterpolationBiLinear">
            <summary>
            Bi-linear interpolation is used
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CInterfaceLayer">
            <summary>
            The <c>CInterfaceLayer</c> object
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.ITaggedObject">
            <summary>
            ITaggedObject
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.ITaggedObject.Tag">
            <summary>
            Tag
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.ITaggedObject.ItemHandle">
            <summary>
            ItemHandle
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.ITaggedObject.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CInterfaceLayer.#ctor(System.String,System.IntPtr,System.IntPtr)">
            <summary>
            Public constructor for the <c>CInterfaceLayer</c> object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CInterfaceLayer.Finalize">
            <summary>
            Destructor for the CInterfaceLayer object
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CInterfaceLayer.m_Tag">
             <summary>
             
            Tag as an object
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CInterfaceLayer.GenTLDeviceList">
             <summary>
             
            List of GenTL devices
             </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CInterfaceLayer.Dispose">
            <summary>
            This object will be cleaned up by the Dispose method.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CInterfaceLayer.Close">
            <summary>
            Close the previously opened <c>CInterfaceLayer</c> object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Jai_FactoryDotNET.CInterfaceLayer.Tag">
             <summary>
             
            Tag as an object
             </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CInterfaceLayer.Name">
            <summary>
            Name of the interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CInterfaceLayer.ItemHandle">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CInterfaceLayer.TransportHandle">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.AverageCounter">
            <summary>
            Helper class to calculate running average 
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.AverageCounter.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.AverageCounter.#ctor(System.Int32)">
            <summary>
            Constructor where the number of elements to be averaged is specified
            </summary>
            <param name="AverageCount">Number of element</param>
        </member>
        <member name="M:Jai_FactoryDotNET.AverageCounter.Reset">
            <summary>
            Reset average
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.AverageCounter.Update(System.Int32)">
            <summary>
            This function is called for each element update.
            It will return the running average
            </summary>
            <returns>Average value for all the elements</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CErrorCounter.#ctor(System.UInt64)">
            <summary>
            Constructor - pass in the value to used to check if counter is a multiple of this value
            </summary>
            <param name="maxCount"></param>
        </member>
        <member name="M:Jai_FactoryDotNET.CErrorCounter.ResetCounter">
            <summary>
            Reset internal counter to 0
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CErrorCounter.UpdateCounter">
            <summary>
            Increment the internal counter
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CErrorCounter.CheckCount">
            <summary>
            Return true if current count MOD input value equals 0
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CErrorCounter.MathMod(System.UInt64,System.UInt64)">
            <summary>
            Internal function to calculate the Modulo - c# does not have a standard 
            way to calculate this.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Jai_FactoryDotNET.CNode">
            \brief GenICam Node object class used by the Managed Factory
            
            The Node class contains all settings related to a GenICam Node
            \sa Jai_FactoryWrapper 
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.FindEnumValue(System.String,System.Boolean)">
            <summary>
            Search for an enumeration value by name. The search will try to mach the Name of the enumeration. If that fails 
            the Description will be searched as well.
            </summary>
            <param name="enumValueName">Name or description to search for in the EnumValue collection</param>
            <param name="findExact">Flag to enforce searching for the exact name or to allow substring search as well</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.#ctor(System.IntPtr)">
            <summary>
            Public constructor for the CNode object. The CNode object will be created based on the Node Handle passed to the constructor
            </summary>
            <param name="nodeHandle">Valid handle to an opened node object</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.Finalize">
            <summary>
            Public destructor
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.ImposeAccessMode(Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode)">
            <summary>
            Set the current access mode of the node. The access mode might change at runtime depending on the values of other nodes.
            </summary>
            <param name="accessMode">Access mode to be imposed to this node</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.ImposeVisibility(Jai_FactoryDotNET.Jai_FactoryWrapper.EConfVisibility)">
            <summary>
            Set the current recommended visibility of the node
            </summary>
            <param name="visibility">New recommended visibility for the node</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.ExecuteCommand">
            <summary>
            Execute the command if the node is of type <c>ICommand</c>
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Node_ExecuteCommand() function return an error</exception>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.Invalidate">
            <summary>
            Invalidate the node
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Name">
            <summary>
            GenICam node name
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.DisplayName">
            <summary>
            User friendly name for the node. If no <c>DisplayName</c> is not found in the XML-file the <c>DisplayName</c> will contain the <c>Name</c> value instead
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.ToolTip">
            <summary>
            Short description of the node. If no <c>Tooltip</c> is not found in the XML-file the <c>Tooltip</c> will contain the <c>DisplayName</c> value instead
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Description">
            <summary>
            Full description of the node. If no <c>Description</c> is not found in the XML-file the <c>Description</c> will contain the <c>Tooltip</c> value instead
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.NameSpace">
            <summary>
            GenICam name space. This can be "Standard" or "Custom"
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Representation">
            <summary>
            Representation of the value in a Graphical User Interface
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.DisplayNotation">
            <summary>
            Display Notation for Float node values in a Graphical User Interface
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.DisplayPrecision">
            <summary>
            Display Precision for Float node values in a Graphical User Interface
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Unit">
            <summary>
            Unit of the value in a Graphical User Interface
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.DocuURL">
            <summary>
            Documentation URL for the node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsCachable">
            <summary>
            Is the node cachable or do we need to read it back once in a while to get changes?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.CachingMode">
            <summary>
            GenICam caching mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.PollingTime">
            <summary>
            Recommended polling time (in milliseconds)
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.EventID">
            <summary>
            Event ID string
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsStreamable">
            <summary>
            Is the node streamable?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsDeprecated">
            <summary>
            Is the node Deprecated?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsSelector">
            <summary>
            Is the node a Selector Node?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.SelectedNodes">
            <summary>
            Selected nodes (only if this is a Selector Node)
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.SelectingNodeNames">
            <summary>
            Names of all Selecting nodes (only if other nodes are selectors for this node)
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.AliasNodeHandle">
            <summary>
            Is there another node that displays the same feature in a different way
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.FloatAliasNodeHandle">
            <summary>
            Is there an IFloat node that displays the same feature as this IInteger node?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IntegerAliasNodeHandle">
            <summary>
            Is there an IInteger node that displays the same feature as this IFloat node?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.EnumAliasNodeHandle">
            <summary>
            Is there an IEnumeration node that displays the same feature as this IFloat node?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.NodeType">
            <summary>
            GenICam node type
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.EnumValues">
            <summary>
            If the node is of type <c>IEnumeration</c>, then the <c>EnumValues</c> array will contain the different enumeration values defined for the node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Tag">
            <summary>
            GenICam node Tag
            This tag can be used for storing any object related to the Node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.NodeHandle">
            <summary>
            The handle of this node. This handle can be used for calling the <c>Jai_FactoryWrapper.J_Node_xxx()</c> functions
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.AccessMode">
            <summary>
            Get/set the current access mode of the node. The access mode might change at runtime depending on the values of other nodes.
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Node_GetAccessMode() or Jai_FactoryWrapper.J_Node_ImposeAccessMode() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Visibility">
            <summary>
            Get/set the current recommended visibility of the node
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Node_GetVisibility() or Jai_FactoryWrapper.J_Node_ImposeVisibility() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Min">
            <summary>
            Get minimum value for the node. The value type depends on the node type
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Max">
            <summary>
            Get maximum value for the node. The value type depends on the node type
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Inc">
            <summary>
            Get increment value for the node. The value type depends on the node type
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Length">
            <summary>
            Get length of a Register node (in bytes). The value type depends on the node type.
            Only nodes of type Jai_FactoryWrapper.EConfNodeType.IRegister, Jai_FactoryWrapper.EConfNodeType.IIntReg, Jai_FactoryWrapper.EConfNodeType.IFloatReg, Jai_FactoryWrapper.EConfNodeType.IStringReg and Jai_FactoryWrapper.EConfNodeType.IMaskedIntReg are supported
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Address">
            <summary>
            Get address of a Register node. The value type depends on the node type.
            Only nodes of type Jai_FactoryWrapper.EConfNodeType.IRegister, Jai_FactoryWrapper.EConfNodeType.IIntReg, Jai_FactoryWrapper.EConfNodeType.IFloatReg, Jai_FactoryWrapper.EConfNodeType.IStringReg and Jai_FactoryWrapper.EConfNodeType.IMaskedIntReg are supported
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsReadable">
            <summary>
            Is the node value readable? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsWritable">
            <summary>
            Is the node value writable? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsImplemented">
            <summary>
            Is the node implemented? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IsAvailable">
            <summary>
            Is the node value available? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.NodeValueType">
            <summary>
            Get the managed datatype of the internal value representation of the node value
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.Value">
            <summary>
            Get/set the current value of the node. The value return type will depend on the GenICam node type
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="T:Jai_FactoryDotNET.CNode.IEnumValue">
            <summary>
            This class contains information about a single enumeration entry node inside an IEnumeration node
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.IEnumValue.#ctor(System.String,System.String,System.String,System.Int64,Jai_FactoryDotNET.Jai_FactoryWrapper.EConfAccessMode)">
            <summary>
            Public constructor for the IEnumValue object
            </summary>
            <param name="Name">GenICam Name of the IEnumEntry node</param>
            <param name="DisplayName">Display name of the IEnumEntry node</param>
            <param name="Description">Description of the IEnumEntry node</param>
            <param name="Value">Value of the IEnumEntry node</param>
            <param name="AccessMode">Access Mode of the IEnumEntry node</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CNode.IEnumValue.ToString">
            <summary>
            Name of the IEnumEntry node
            </summary>
            <returns></returns>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.Name">
            <summary>
            Name of the IEnumEntry node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.DisplayName">
            <summary>
            Display Name of the IEnumEntry node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.Description">
            <summary>
            Description of the IEnumEntry node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.Value">
            <summary>
            Integer value of the IEnumEntry node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.AccessMode">
            <summary>
            Access Mode of the IEnumEntry node
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.IsReadable">
            <summary>
            Is the IEnumEntry node value readable? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.IsWritable">
            <summary>
            Is the IEnumEntry IEnumEntry node value writable? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.IsImplemented">
            <summary>
            Is the IEnumEntry node implemented? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CNode.IEnumValue.IsAvailable">
            <summary>
            Is the IEnumEntry node value available? This is calculated based on the current access mode
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CTransportLayer">
            <summary>
            The <c>CTransportLayer</c> object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CTransportLayer.#ctor(System.String,System.IntPtr)">
            <summary>
            Public constructor for the <c>CTransportLayer</c> object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CTransportLayer.Finalize">
            <summary>
            Destructor for the CTransportLayer object
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CTransportLayer.m_Tag">
             <summary>
             
            Tag as an object
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CTransportLayer.InterfaceList">
             <summary>
             
            List of transport layer names
             </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CTransportLayer.Dispose">
            <summary>
            This object will be cleaned up by the Dispose method.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CTransportLayer.Close(System.Boolean)">
            <summary>
            Close the previously opened <c>CTransportLayer</c> object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Jai_FactoryDotNET.CTransportLayer.Tag">
             <summary>
             
            Tag 
             </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CTransportLayer.Name">
            <summary>
            Name of the transport layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CTransportLayer.ItemHandle">
            <summary>
            Handle to underlying transport layer
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.RGBSettings">
            <summary>
            Summary description for Settings.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.RGBSettings.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.RGBSettings.#ctor(Jai_FactoryDotNET.RGBSettings)">
            <summary>
            Constructor that copies the contents of another RGBSetting
            </summary>
            <param name="SourceSettings">Source RGBSetting object to copy from</param>
        </member>
        <member name="M:Jai_FactoryDotNET.RGBSettings.LoadSettings(Jai_FactoryDotNET.RGBSettings@,System.String)">
            <summary>
            Load RGB settings from XML file
            </summary>
            <param name="DesinationSettings">Reference to RGBSetting object to update with values read from XML file</param>
            <param name="Filename">Filename of the RGB settings XML file</param>
        </member>
        <member name="M:Jai_FactoryDotNET.RGBSettings.SaveSettings(Jai_FactoryDotNET.RGBSettings@,System.String)">
            <summary>
            Save RGB settings to XML file
            </summary>
            <param name="SourceSettings">Reference to RGB setting to be saved</param>
            <param name="Filename">Filename of the RGB settings XML file</param>
        </member>
        <member name="P:Jai_FactoryDotNET.RGBSettings.RGain">
            <summary>
            Red gain
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.RGBSettings.GGain">
            <summary>
            Green gain
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.RGBSettings.BGain">
            <summary>
            Blue gain
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CLocalDevice">
            <summary>
            The <c>CLocalDevice</c> object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDevice.#ctor(System.String,System.IntPtr)">
            <summary>
            Public constructor for the <c>CLocalDevice</c> object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDevice.Finalize">
            <summary>
            Destructor for the CLocalDevice object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDevice.LoadSettings">
             <summary>
             
            LoadSettings
             </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDevice.SaveSettings">
             <summary>
             
            SaveSettings
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDevice.m_Tag">
             <summary>
             
            Tag as an object
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CLocalDevice.GenTLDeviceList">
             <summary>
             
            List of GenTL devices
             </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDevice.Dispose">
            <summary>
            This object will be cleaned up by the Dispose method.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CLocalDevice.Close">
            <summary>
            Close the previously opened <c>CLocalDevice</c> object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.Tag">
             <summary>
             
            Tag as an object
             </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.Name">
            <summary>
            Name of the interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.ItemHandle">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.RemoteCamera">
            <summary>
            Remote Camera.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.EnableMulticasting">
            <summary>
            Enable or disable multi-casting.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.MulticastIPAddress">
            <summary>
            Multi-cast address.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.AcquisitionBufferCount">
             <summary>
             
            AcquisitionBufferCount
             </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.EnablePacketResend">
             <summary>
             
            EnablePacketResend
             </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.PassCorruptFrames">
             <summary>
             
            PassCorruptFrames
             </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.ReadWriteAckTimeout">
            <summary>
            Read Write Ack Timeout.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.ReadWriteRetryTimeout">
            <summary>
            Read Write Retry Timeout.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.GevControlTimeout">
            <summary>
            Read Write Pending Timeout.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.GevControlRetryCount">
            <summary>
            Read Write Retry Count.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CLocalDevice.ManifestEntrySelector">
            <summary>
            Read Write Retry Count.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CFactory">
             \brief Factory object class
             
             The Factory class contains all settings related to the Factory. It used the Jai_FactoryWrapper to communicate with the unmanaged Jai_Factory.dll
             \sa Jai_FactoryWrapper 
            
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.log">
             <summary>
             
            Get log defined in the file log4net.config
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.CameraList">
            <summary>
            <para>List of <c>GigE CCamera</c> objects found during Device Discovery. The Device Discovery is performed using the <c>UpdateCameraList()</c> or <c>UpdateDeviceList()</c> functions</para>
            <para>
            The contents of the Camera List will depend on the PreferredDriverType selected. If the PreferredDriverType is EDriverType.Undefined the Camera list will include
            the sum of cameras found across all driver types. If both the Socket Driver and the Filter Driver is installed, cameras will show up twice.
            </para>
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CFactory.UpdateCameraList(Jai_FactoryDotNET.CFactory.EDriverType)"/>
            <seealso cref="T:Jai_FactoryDotNET.CCamera"/>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Jai_FactoryDotNET.CFactory.GenTLDeviceList" -->
        <member name="F:Jai_FactoryDotNET.CFactory.DeviceList">
            <summary>
            <para>List of <c>GigE AND generic GenTL CCamera</c> objects found during Device Discovery. The Device Discovery is performed using the <c>UpdateCameraList()</c> or <c>UpdateDeviceList()</c> functions</para>
            <para>
            The contents of the Device List will depend on the PreferredDriverType selected (GigE devices only). If the PreferredDriverType is EDriverType.Undefined the Camera list will include
            the sum of cameras found across all driver types. If both the Socket Driver and the Filter Driver is installed, cameras will show up twice.
            </para>
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CFactory.UpdateCameraList(Jai_FactoryDotNET.CFactory.EDriverType)"/>
            <seealso cref="T:Jai_FactoryDotNET.CCamera"/>
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.TransportList">
             <summary>
             
            List of transport layer names
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.FactoryHandle">
            <summary>
            Handle to the Factory.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.#ctor">
            <summary>
            Public constructor for the <c>CFactory</c> object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.Finalize">
            <summary>
            Destructor for the Factory object
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.Dispose">
            <summary>
            This object will be cleaned up by the Dispose method.
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.Open">
            <summary>
            Open the <c>CFactory</c> object. This function has to be called in order call any other function in the <c>CFactory</c> object!
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.Open(System.String)">
            <summary>
            Open the <c>CFactory</c> object. This function has to be called in order call any other function in the <c>CFactory</c> object!
            </summary>
            <param name="RegistryFile">File name and path for the Registry XML file</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.Close">
            <summary>
            Close the previously opened <c>CFactory</c> object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CFactory.UpdateCameraList(Jai_FactoryDotNET.CFactory.EDriverType)">
            <summary>
            <para>
            Update the <c>CCamera</c> List using GigE Vision Device Discovery
            </para>
            <para>
            The contents of the Camera List will depend on the PreferredDriverType selected. If the PreferredDriverType is EDriverType.Undefined the Camera list will include
            the sum of cameras found across all driver types. If both the Socket Driver and the Filter Driver is installed, cameras will show up twice.
            </para>
            </summary>
            <seealso cref="T:Jai_FactoryDotNET.CCamera"/>
            <seealso cref="P:Jai_FactoryDotNET.CFactory.PreferredDriverType"/>
            <param name="preferredDriverType"></param>
            <returns>Boolean indicating if there has been any changes</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.CFactory.SendActionCommand(System.UInt32,System.UInt32,System.UInt32,Jai_FactoryDotNET.Jai_FactoryWrapper.ActionCommandAck[]@,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.CFactory.SendActionCommand(System.UInt32,System.UInt32,System.UInt32)" -->
        <member name="M:Jai_FactoryDotNET.CFactory.UpdateDeviceList(Jai_FactoryDotNET.CFactory.EDriverType)">
            <summary>
            Get the list of transport layers.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.PreferredDriverType">
            <summary>
            The preferred driver type used to filter the cameras found during Device Discovery
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CFactory.UpdateCameraList(Jai_FactoryDotNET.CFactory.EDriverType)"/>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.EnableAutoForceIP">
            <summary>
            This flag enables automatic Force IP handling for the Device Discovery. It has to be set up before calling \c UpdateCameraList()
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CFactory.UpdateCameraList(Jai_FactoryDotNET.CFactory.EDriverType)"/>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.Version">
            <summary>
            <c>Jai_Factory.dll</c> version information
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Factory_GetInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.BuildDate">
            <summary>
            <c>Jai_Factory.dll</c> Build Date
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Factory_GetInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.BuildTime">
            <summary>
            <c>Jai_Factory.dll</c> Build Time
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Factory_GetInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.Manufacturer">
            <summary>
            <c>Jai_Factory.dll</c> Manufacturer
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Factory_GetInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CFactory.NumOfCameras">
            <summary>
            Get the number of cameras found during Device Discovery
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_Factory_GetNumOfCameras() functions return an error</exception>
        </member>
        <member name="T:Jai_FactoryDotNET.CFactory.EDriverType">
            <summary>
            Driver Type.
            This enumeration is used by the CFactory to select which type of driver interface that is preferred during Device Discovery
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.EDriverType.FilterDriver">
            <summary>
            JAI Filter Driver
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.EDriverType.SocketDriver">
            <summary>
            Windows Socket Driver
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CFactory.EDriverType.Undefined">
            <summary>
            Undefined Driver Type
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera">
            \brief Camera object class used by the Managed Factory
            
            The Camera class contains all settings related to a camera
            \sa Jai_FactoryWrapper 
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.m_ParentLocalDevice">
             <summary>
             
            CLocalDevice m_ParentLocalDevice
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.log">
             <summary>
             
            Get log defined in the file log4net.config
             </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.FactoryHandle">
            <summary>
            Factory Handle to be used in the Jai_FactoryWrapper functions (such as <c>Jai_FactoryWrapper.J_Factory_Open()</c>, <c>Jai_FactoryWrapper.J_Factory_Close()</c> and <c>Jai_FactoryWrapper.J_Factory_UpdateCameraList()</c>)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.CameraHandle">
            <summary>
            Camera Handle to be used in the Jai_FactoryWrapper functions(such as <c>Jai_FactoryWrapper.J_Camera_Open()</c>, <c>Jai_FactoryWrapper.J_Camera_Close()</c> and <c>Jai_FactoryWrapper.J_Camera_CreateDataStream()</c>)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.StreamHandle">
            <summary>
            Stream Handle to be used in the Jai_FactoryWrapper functions(such as <c>Jai_FactoryWrapper.J_DataStream_AnnounceBuffer()</c>, <c>Jai_FactoryWrapper.J_DataStream_StartAcquisition()</c> and <c>Jai_FactoryWrapper.J_DataStream_GetBufferInfo()</c>)
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.WindowHandle">
            <summary>
            View Window Handle to be used in the Jai_FactoryWrapper functions (such as <c>J_Image_ShowImage()</c>, <c>J_Image_SetImageOffset()</c> and <c>J_Image_MoveViewWindow()</c>)
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.#ctor">
            <summary>
            Default constructor for the <c>CCamera</c> object.
            
            This constructor is provided for <c>inheritance</c>
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.#ctor(System.IntPtr,System.String,System.IntPtr,System.IntPtr,System.String)">
            <summary>
            Public constructor for the <c>CCamera</c> object.
            
            This constructor is normally not used directly since a collection of CCamera objects will automatically be created using the Factory object during <c>CFactory.UpdateCameraList()</c>
            </summary>
            <param name="factoryHandle">Valid handle to an opened Factory object. This handle is obtained from the <c>CFactory</c> object like <c>myFactory.FactoryHandle</c></param>
            <param name="cameraID">Unique camera ID string returned by Jai_FactoryWrapper.J_Factory_GetCameraIDByIndex()</param>
            <param name="hTL">Handle of the transport layer</param>
            <param name="hIF">Handle of the interface layer</param>
            <param name="genericName">Name returned from J_GenTL_IFGetDeviceName</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.CCamera.#ctor(System.String,System.IntPtr,System.IntPtr)" -->
        <member name="M:Jai_FactoryDotNET.CCamera.Finalize">
            <summary>
            Destructor for the <c>CCamera</c> object
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera._IsOpen">
            <summary>
            Flag showing if the camera connection has been opened successfully
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera._ConnectionStatus">
            <summary>
            Flag showing the connection type
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Open">
            <summary>
            Opens the connection to the camera
            
            When the camera has been sucessfully opened all the configuration properties will be read automatically. 
            It will also be detected if the camera will be sending Bayer coded color images or not.
            </summary>
            <seealso cref="P:Jai_FactoryDotNET.CCamera.IsBayerCamera"/>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Open(Jai_FactoryDotNET.Jai_FactoryWrapper.EDeviceAccessFlags,System.UInt32)">
            <summary>
            Opens the connection to the camera
            
            When the camera has been successfully opened all the configuration properties will be read automatically.
            It will also be detected if the camera will be sending Bayer coded color images or not.
            </summary>
            <seealso cref="P:Jai_FactoryDotNET.CCamera.IsBayerCamera"/>
            <param name="OpenFlags">Device access Flags</param>
            <param name="McIP">Multicast IP address</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Close">
            <summary>
            Closes a previously opened connection to the camera
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.Open"/>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveFrameWindow">
            <summary>
            Save the View Window location and size
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.LoadFrameWindow">
            <summary>
            Load the View Window location and size
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StartAcquisition">
            <summary>
            Start image transfer inside camera using the GigE Vision stream protocol. This is done using the standard GigE Vision command <c>AcquisitionStart</c> via GenICam
            
            It does NOT set up any Data Stream to acquire the images. To do this use <c>StartImageAcquisition()</c> instead.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StopAcquisition">
            <summary>
            Stop image transfer inside camera using the GigE Vision stream protocol. This is done using the standard GigE Vision command AcquisitionStop via GenICam
            
            This does not free up any Data Stream. To do so use the <c>StopImageAcquisition()</c>
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)">
            <summary>
            Start image aquisition from the camera and optionally display the images in a View Window
            
            This is an easy way to get images from the camera and optionally display Live Video. The new View Window is internally create using <c>Jai_FactoryWrapper.J_Image_OpenViewWindow()</c>
            and a GigE Vision Stream channel is created internally using <c>Jai_FactoryWrapper.J_Camera_CreateDataStream()</c>.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenViewWindow(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE@,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenStream(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32,System.UInt32)"/>
            <param name="ShowWindow">Display the acquired images in a window or not</param>
            <param name="BufferCount">Number of buffers to be allocated for the image acquisition</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32,System.IntPtr)">
            <summary>
            Start image aquisition from the camera and optionally display the images inside a Child Window
            
            This is an easy way to get images from the camera and optionally display Live Video. The Child Window will be used for the image display.
            and a GigE Vision Stream channel is created internally using <c>Jai_FactoryWrapper.J_Camera_CreateDataStream()</c>.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenViewWindow(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE@,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenStream(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32,System.UInt32)"/>
            <param name="ShowWindow">Display the acquired images in a window or not</param>
            <param name="BufferCount">Number of buffers to be allocated for the image acquisition</param>
            <param name="ChildWindowHandle">Handle to the Child Window to be used for Inage Display. This Can be IntPtr.Zero if the display is overlapped.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32,System.UInt32)">
            <summary>
            Start image aquisition from the camera using Multi Cast and optionally display the images in a View Window
            
            This is an easy way to get images from the camera and optionally display Live Video. The new View Window is internally create using <c>Jai_FactoryWrapper.J_Image_OpenViewWindow()</c>
            and a GigE Vision Stream channel is created internally using <c>Jai_FactoryWrapper.J_Camera_CreateDataStream()</c>.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenViewWindow(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE@,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenStream(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32,System.UInt32)"/>
            <param name="ShowWindow">Display the acquired images in a window</param>
            <param name="BufferCount">Number of buffers to be allocated for the image acquisition</param>
            <param name="McIP">Multicast IP address</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32,System.UInt32,System.IntPtr)">
            <summary>
            Start image aquisition from the camera using Multi Cast and optionally display the images in a Child Window
            
            This is an easy way to get images from the camera and optionally display Live Video. The new View Window is internally create using <c>Jai_FactoryWrapper.J_Image_OpenViewWindow()</c>
            and a GigE Vision Stream channel is created internally using <c>Jai_FactoryWrapper.J_Camera_CreateDataStream()</c>.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenViewWindow(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.POINT@,Jai_FactoryDotNET.Jai_FactoryWrapper.SIZE@,System.IntPtr@)"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_Image_OpenStream(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32,System.UInt32)"/>
            <param name="ShowWindow">Display the acquired images in a window</param>
            <param name="BufferCount">Number of buffers to be allocated for the image acquisition</param>
            <param name="McIP">Multicast IP address</param>
            <param name="ChildWindowHandle">Handle to the Child Window to be used for Inage Display. This Can be IntPtr.Zero if the display is overlapped.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition">
            <summary>
            Stop image acquisition and close the live view window (if it has been opened)
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StopImageAcquisitionEx">
            <summary>
            Stop image acquisition and close the live view window (if it has been opened)
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SetGain(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Set the white balance gain values used for the image acquisition and live video display
            
            These values are only used if the camera is sending Bayer images
            </summary>
            <param name="redGain">Gain of the red channel</param>
            <param name="greenGain">Gain of the green channel</param>
            <param name="blueGain">Gain of the blue channel</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetGain(System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Get the white balance gain values used for the image acquisition and live video display
            
            These values are only used if the camera is sending Bayer images
            </summary>
            <param name="redGain">Gain of the red channel</param>
            <param name="greenGain">Gain of the green channel</param>
            <param name="blueGain">Gain of the blue channel</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ExecuteWhiteBalance(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Execute an automatic white balance calculation and read the resulting gain values and used them for the 
            mage acquisition and the live video display.
            
            The image acquisition needs to be started in advance using <c>StartImageAcquisition()</c>
            </summary>
            <param name="AWBXOffset">X Offset of the White Balance calculation area used from in the image</param>
            <param name="AWBYOffset">Y Offset of the White Balance calculation area used from in the image</param>
            <param name="AWBWidth">Width of the White Balance calculation area used from in the image</param>
            <param name="AWBHeight">Height of the White Balance calculation area used from in the image</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetScriptErrorString">
            <summary>
            Returns the last error detected during load and/or validation of the script selected by RunScript() or ValidateScript()
            </summary>
            <returns>Error string if an error occcured. Else it returns an empty string.</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ValidateScript(Jai_FactoryDotNET.CCamera.Script)">
            <summary>
            This validates the contents of a Script file (checks if the features exists and that the values are within legal range).
            If an error is detected an error description string will be created. It can be retrieved using GetScriptErrorString()
            </summary>
            <param name="script">Script to be validated</param>
            <returns>True if the script is valid. False if a validation error is detected. Use GetScriptErrorString() to get any warning messages.</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetScriptProgress">
            <summary>
            Get the current progress (between 0 and 100) of the running script. It will return -1 if no script is running.
            </summary>
            <returns>-1 if script is nut running. Otherwise [0-100]</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetScriptLastCommand">
            <summary>
            Get the Last Executed command of the running script. It will return null if no script is running.
            </summary>
            <returns>null if script is nut running. Otherwise last command object</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.RunScript(System.String)">
            <summary>
            Run feature value script and update values in the camera. If an error is returned then a description of the error can be retrieved using GetScriptErrorString()
            </summary>
            <param name="filename">Filename of the script to be run</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.RunScript(Jai_FactoryDotNET.CCamera.Script)">
            <summary>
            Run feature value script and update values in the camera. If an error is returned then a description of the error can be retrieved using GetScriptErrorString()
            </summary>
            <param name="script">Script to be run</param>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.CreateSettingsScript">
            <summary>
            Create a script that contains the complete camera settings that can be saved and later restored
            </summary>
            <returns>Script with all camera settings</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.WriteRegister(System.Int64,System.UInt32)">
            <summary>
            Big endian only. Write a DWORD register value directly to the camera. This does not involve GenICam
            </summary>
            <param name="address">Register address</param>
            <param name="value">Value to be written</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.WriteRegister(System.Int64,System.UInt32,System.Boolean)">
            <summary>
            Write a DWORD register value directly to the camera. This does not involve GenICam
            </summary>
            <param name="address">Register address</param>
            <param name="value">Value to be written</param>
            <param name="bIsBigEndian">Specify endianess</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ReadRegister(System.Int64,System.UInt32@)">
            <summary>
            Big endian only. Read a DWORD register directly from the camera. This does not involve GenICam
            </summary>
            <param name="address">Register address</param>
            <param name="value">Reference to a variable where the register value will be written</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ReadRegister(System.Int64,System.UInt32@,System.Boolean)">
            <summary>
            Read a DWORD register directly from the camera. This does not involve GenICam
            </summary>
            <param name="address">Register address</param>
            <param name="value">Reference to a variable where the register value will be written</param>
            <param name="bIsBigEndian">Specify endianess</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetNodeValue(System.String)">
            <summary>
            Get the current value of a named GenICam node
            
            This function will return the current value of a GenICam node. The return value type will depend on the node type.
            </summary>
            <param name="nodeName">Name of the GenICam node. This name has to be the GenICam name - not the Display Name</param>
            <returns>value object</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetNode(System.String)">
            <summary>
            Get a GenICam node by name
            
            This function will search for a GenICam node with the specified name
            </summary>
            <param name="nodeName">Name of the GenICam node. This name has to be the GenICam name - not the Display Name</param>
            <returns>CNode object if the GenICam node is found</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jai_FactoryDotNET.CCamera.GetSubFeatures(System.String)" -->
        <member name="M:Jai_FactoryDotNET.CCamera.SaveNextFrame(System.String)">
            <summary>
            Save the next frame from the camera to disk as a tiff image
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveNextFrame(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat,System.Byte)">
            <summary>
            Save the next frame from the camera to disk
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <param name="FileFormat">File format to be used.</param>
            <param name="EncoderParameter">File format specific encoder parameter. If Jpeg file format is selected this parameter specifies the Quality level for the jpeg file. Acceptable value range is 1 to 100, default is 75, 5-95 is useful range. Larger number goes toward higher quality and larger file size.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveLastFrame(System.String)">
            <summary>
            Save the last frame received from the camera to disk as a tiff image. This image might have transformations and a LUT applied!
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveLastRawFrame(System.String)">
            <summary>
            Save the last frame received from the camera to disk as a tiff image
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveLastFrame(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat,System.Byte)">
            <summary>
            Save the last frame received from the camera to disk. This image might have transformations and a LUT applied!
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <param name="FileFormat">File format to be used.</param>
            <param name="EncoderParameter">File format specific encoder parameter. If Jpeg file format is selected this parameter specifies the Quality level for the jpeg file. Acceptable value range is 1 to 100, default is 75, 5-95 is useful range. Larger number goes toward higher quality and larger file size.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveLastRawFrame(System.String,Jai_FactoryDotNET.Jai_FactoryWrapper.ESaveFileFormat,System.Byte)">
            <summary>
            Save the last frame received from the camera to disk
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <param name="FileFormat">File format to be used.</param>
            <param name="EncoderParameter">File format specific encoder parameter. If Jpeg file format is selected this parameter specifies the Quality level for the jpeg file. Acceptable value range is 1 to 100, default is 75, 5-95 is useful range. Larger number goes toward higher quality and larger file size.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveLastFrameRaw(System.String)">
            <summary>
            Save the last frame received from the camera to disk as a raw binary file. This image might have transformations and a LUT applied!
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.SaveLastRawFrameRaw(System.String)">
            <summary>
            Save the last frame received from the camera to disk as a raw binary file
            </summary>
            <param name="FileName">File name and path of the image to be saved.</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ZoomIn">
            <summary>
            Zoom in on the Live Video Window display.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            This will zoom in using the minimal step size.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ZoomIn(System.Int32)">
            <summary>
            Zoom in on the Live Video Window display.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            This will zoom in using the specified step size.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="zoomSpeed">Zoom step size. Zoom range is between 1 and 100</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ZoomOut">
            <summary>
            Zoom out on the Live Video Window display.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            This will zoom out using the minimal step size.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ZoomOut(System.Int32)">
            <summary>
            Zoom out on the Live Video Window display.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            This will zoom out using the specified step size.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="zoomSpeed">Zoom step size. Zoom range is between 1 and 100</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ZoomReset">
            <summary>
            Remove the zoom of the Live Video Window display.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.ZoomDirect(System.Int32)">
            <summary>
            Zoom the Live Video Window display to an absolute zoom position.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="zoomPosition">Absolut zoom position. Zoom range is between 1 and 100</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateLeftUp">
            <summary>
            Navigate Left and Up using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateLeftUp(System.Int32)">
            <summary>
            Navigate Left and Up using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize">Navigation step size in pixels</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateUp">
            <summary>
            Navigate Up using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateUp(System.Int32)">
            <summary>
            Navigate Up using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateRightUp">
            <summary>
            Navigate Right and Up using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateRightUp(System.Int32)">
            <summary>
            Navigate Right and Up using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateLeft">
            <summary>
            Navigate Left using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateLeft(System.Int32)">
            <summary>
            Navigate Left using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateCenter">
            <summary>
            Navigate back to the center of the image.
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateRight">
            <summary>
            Navigate Right using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateRight(System.Int32)">
            <summary>
            Navigate Right using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateLeftDown">
            <summary>
            Navigate Left and Down using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateLeftDown(System.Int32)">
            <summary>
            Navigate Left and Down using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateDown">
            <summary>
            Navigate Down using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateDown(System.Int32)">
            <summary>
            Navigate Down using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateRightDown">
            <summary>
            Navigate Right and Down using minimum step size (a single pixel).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.NavigateRightDown(System.Int32)">
            <summary>
            Navigate Right and Down using specified step size (in pixels).
            
            This will change the Live Video Window display position when the Video has been zoomed in.
            The Live Video Window display is opened using <c>StartImageAcquisition()</c> with the <c>ShowWindow</c> parameter set to <c>true</c>.
            
            This is only possible if the <c>StretchLiveVideo</c> property is enabled.
            </summary>
            <param name="stepSize"></param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.EstimatedInterPacketDelay(System.Double)">
            <summary>
            This function estimate an initial Inter-Packet Delay value to be used with this camera. This value has to be thought of as a 
            starting point for finding the optimal Inter-Packet Delay value for a multi-camera system. The calculation is based on the
            assumption that if the stream channel communication is spread over time as much as possible using the Inter-Packet Delay - but
            only so much that the maximum specified frame rate still can be achieved, then the camera will have the minimal impact on the 
            communication from the other cameras connected on the same Gigabit Ethernet network.
            
            A little overhead should always be reserved for retransmissions for the image stream so it is set to the default of 95.0%
            </summary>
            <param name="maxFramesPerSecond">Maximum frame-rate to be expected from the camera.</param>
            <returns>New Inter-Packet Delay value</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.EstimatedInterPacketDelay(System.Double,System.Double)">
            <summary>
            This function estimate an initial Inter-Packet Delay value to be used with this camera. This value has to be thought of as a 
            starting point for finding the optimal Inter-Packet Delay value for a multi-camera system. The calculation is based on the
            assumption that if the stream channel communication is spread over time as much as possible using the Inter-Packet Delay - but
            only so much that the maximum specified frame rate still can be achieved, then the camera will have the minimal impact on the 
            communication from the other cameras connected on the same Gigabit Ethernet network.
            
            A little overhead should always be reserved for retransmissions for the image stream so it is not adviced to use 100% as the Expected Bandwidth usage.
            A typical value would be around 95%
            </summary>
            <param name="maxFramesPerSecond">Maximum frame-rate to be expected from the camera.</param>
            <param name="expectedBandWidthUsagePercentage">Expected bandwidth usage for this camera.</param>
            <returns>New Inter-Packet Delay value</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StartAsyncImageRecording(System.Int32,Jai_FactoryDotNET.CCamera.AsyncImageRecordingMode,System.Int32)">
            <summary>
            Records multiple raw images into memory. The images will be stores and can be accessed later using GetRecordedImage() or GetRecordedImages().
            
            The image recording will be stopped automatically if we are unable to allocate new memory to hold the recorded frames.
            </summary>
            <param name="count">Number of frames to be recorded. If this parameter is 0 the Image Recording will be cancelled and all images will be freed.</param>
            <param name="mode">Recording mode. Either List or Cyclic</param>
            <param name="skipCount">Number of frames to be skipped during the Asynchronous Image Recording</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.StopAsyncImageRecording">
            <summary>
            Stop a previously started Asynchronous Image recording.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetAsyncRecordedImage(System.Int32,Jai_FactoryDotNET.Jai_FactoryWrapper.ImageInfo@)">
            <summary>
            Get one of the images that has been recorded asynchronously. If the index is wrong this function will return null.
            </summary>
            <param name="index">Zero-based index of the recorded image</param>
            <param name="pImageInfo">Reference to an ImageInfo structure</param>
            <returns>Jai_FactoryWrapper.EFactoryError</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.GetAsyncRecordedImages">
            <summary>
            Get the complete list of the recorded images
            </summary>
            <returns>List of raw images recorded using StartAsyncImageRecording()</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.FreeAsyncRecordedImages">
            <summary>
            Free up all the images that has been captured
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.disposed">
            @} // End group CAM_ASYNC_RECORDING
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Dispose">
            <summary>
            This object will be cleaned up by the Dispose method.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.m_hTL">
            <summary>
            Handle of transport layer
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.m_hIF">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.m_hLocalDevice">
            <summary>
            Handle to underlying device layer
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Jai_FactoryDotNET.CCamera.m_bIsGeneric" -->
        <member name="P:Jai_FactoryDotNET.CCamera.Tag">
            <summary>
            Camera Tag
            This tag can be used for storing any object related to the camera
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.FramesPerSecond">
            <summary>
            Average frames received per second. This values is automatically updated when Image Acquisition is active.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.FramesDisplayedPerSecond">
            <summary>
            Average frames displayed in the Live Video window per second. This can be less than the number of frames received per second if the SkipImageDisplayWhenBusy is set to True. This values is automatically updated when Image Aquisition is active.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ImageSize">
            <summary>
            Image Size in bytes for the last received image. This will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.SizeX">
            <summary>
            Offset X for the last received image. This will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.SizeY">
            <summary>
            Size Y for the last received image. This will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.OffsetX">
            <summary>
            Offset X for the last received image. This will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.OffsetY">
            <summary>
            Offset Y for the last received image. This will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.TimeStamp">
            <summary>
            Timestamp from the last received image. This timestamp will be overwritten when the next images is received.
            
            The unit of the timestamp is "Timestamp Ticks" specific to the camera. The Timestamp tick frequency can be read from the camera using GenICam node <c>GevTimestampTickFrequency</c>
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.TimeStampMs">
            <summary>
            Timestamp from the last received image in Milliseconds. This timestamp will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.BlockId">
            <summary>
            Block ID from the GigE Vision Stream for the last received image. This Block ID will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.TickFrequency">
            <summary>
            The unit of the TimeStamp value specific to the camera. The Timestamp tick frequency can be read from the camera using GenICam node <c>GevTimestampTickFrequency</c>
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.MissingPackets">
            <summary>
            Number of missing packets from the last received frame. This value will be overwritten when the next images is received.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.FrameCounter">
            <summary>
            Total number of images received. This value can be reset by assigning 0 to the value
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.TotalMissingPackets">
            <summary>
            Total number of missing packets from the received images. This value can be reset by manually setting the value to 0
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.StretchLiveVideo">
            <summary>
            Stretch the images from the cameras in the Live Video window
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.EnableMouseZoom">
            <summary>
            Enable mouse zoom in the Live Video window
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.EnableMouseCursorDisplay">
            <summary>
            Enable mouse cursor display in the Live Video window
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.RestoreLiveVideoWindow">
            <summary>
            Automatically save and restore the Live Video Window position and size when Image Acquisition is started. The position and size will be saved individually for each camera when Image Acquisition is stopped.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.LiveVideoWindowRectangle">
            <summary>
            Set or get the Live Video Window location and size
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.SkipImageDisplayWhenBusy">
            <summary>
            Skips the images display from the camera in the Live Video window if the image acquisition buffer in the Stream Channel is running full.
            The images will then only be displayed if no buffers are awaiting delivery.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.RotateImage">
            <summary>
            Rotate the image before displaying it. The rotation is determined by RotationType
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ImageRotateType">
            <summary>
            Select the type of rotation to be performed on the image before displaying it
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.FlipImageHorizontally">
            <summary>
            Flip the image horizontally (mirror) before displaying it.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.FlipImageVertically">
            <summary>
            Flip the image vertically (upside-down) before displaying it.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.EnableLUT">
            <summary>
            Use Lookup-table before image display.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.LUT">
            <summary>
            Use Lookup-table before image display.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsOpen">
            <summary>
            Flag showing if the camera connection has been opened successfully
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsReadOnly">
            <summary>
            Flag showing if the camera connection has been opened as ReadOnly or not
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConnectionStatus">
            <summary>
            Current connection status for the camera. This status is maintained based on events from the Transport Layer
            
            Notifications on changes in the connection status is done by the <c>CDevice.NewConnectionStatusDelegate</c> delegate
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsAcquisitionRunning">
            <summary>
            Flag showing if the camera is currently streaming images to the PC
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsLastFrameAvailable">
            <summary>
            Flag showing if the last received frame is stored so it can be saved later using SaveLastFrame()
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.LastFrameCopy">
            <summary>
            Get a copy of the last received frame (after any processing such as transformations and LUT has been applied)
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.LastRawFrameCopy">
            <summary>
            Get a copy of the last received frame directly from the camera
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsBayerCamera">
            <summary>
            Flag showing if the camera is sending images in Bayer format to the PC
            </summary>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to the Jai_FactoryWrapper functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.AcquisitionStartFlag">
            <summary>
            This flag is determining how the Image Acquisition is started. It must be set before calling <c>StartImageAcquisition()</c>
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.CameraID">
            <summary>
            Unique camera ID obtained using the <c>J_Factory_GetCameraIDByIndex()</c>
            
            This unique string contains information about Transport Layer, Driver Type, NIC interface MAC-address etc.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.Manufacturer">
            <summary>
            Manufacturer Name obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ModelName">
            <summary>
            Model Name obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.DeviceClass">
            <summary>
            GigE Vision Device Class. This indicated the streaming capabilities of the device introduced in GigE Vision 1.2
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IPAddress">
            <summary>
            IP Address obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.MACAddress">
            <summary>
            MAC address obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.UserName">
            <summary>
            Used-defined Name obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.SerialNumber">
            <summary>
            Serial Number obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.InterfaceID">
            <summary>
            Interface ID obtained using the <c>J_Factory_GetCameraInfo()</c>. The camera connection does not need to be opened before this information is available.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.DriverType">
            <summary>
            Drivertype derived from the <c>CCamera.InterfaceID</c> string (For instance SocketDriver or FilterDriver)
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumOfDataStreams">
            <summary>
            Number of Data Streams available for the camera.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigModelName">
            <summary>
            Model Name read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigVendorName">
            <summary>
            Vendor Name read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigToolTip">
            <summary>
            Tooltip read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigStandardNameSpace">
            <summary>
            Standard Name Space read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigGenApiVersion">
            <summary>
            GenApi Version read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigSchemaVersion">
            <summary>
            GenICam Schema Version read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigDeviceVersion">
            <summary>
            Camera Device Version read from the Configuration file (XML-file) when the camera connection has been opened
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigProductGuid">
            <summary>
            Unique Product GUID read from the Configuration file (XML-file) when the camera connection has been opened
            
            This GUID string will be uniquely identifying the camera product type
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ConfigVersionGuid">
            <summary>
            Configuration File Version GUID read from the Configuration file (XML-file) when the camera connection has been opened
            
            This GUID string will be uniquely identifying the Configuration File Version
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.EnableColorInterpolation">
            <summary>
            Enable Bayer Color Interpolation
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ColorInterpolationAlgorithm">
            <summary>
            Bayer Color Interpolation Algorithm
            </summary>
        </member>
        <member name="E:Jai_FactoryDotNET.CCamera.NewImageDelegate">
            <summary>
            This delegate will be called for every image captured
            </summary>
            <example>
            <code>
            // To attach to the NewImageDelegate you have to do like this:
            myCamera.NewImageDelegate += new Jai_FactoryWrapper.ImageCallBack(myLocalNewImageFunction);
            
            void myLocalNewImageFunction(ref Jai_FactoryWrapper.ImageInfo ImageInfo)
            {
                // Do something with the image (but remember to make it as fast as possible!)
            }
            
            // To remove the delegate again you have to do like this:
            myCamera.NewImageDelegate -= new Jai_FactoryWrapper.ImageCallBack(myLocalNewImageFunction);
            </code>
            </example>
        </member>
        <member name="E:Jai_FactoryDotNET.CCamera.ViewWindowEventDelegate">
            <summary>
            This delegate will be called for every View Window event
            </summary>
            <example>
            <code>
            // To attach to the ViewWindowEventDelegate you have to do like this:
            myCamera.ViewWindowEventDelegate += new Jai_FactoryWrapper.ImageViewWindowDelegate(myLocalViewWindowDelegateFunction);
            
            void myLocalViewWindowDelegateFunction(CCamera camera, EIVWCallbackType Type, ref IVWCallbackValue CallbackValue)
            {
                // Do something with the event (but remember to make it as fast as possible!)
            }
            
            // To remove the delegate again you have to do like this:
            myCamera.ViewWindowEventDelegate -= new Jai_FactoryWrapper.ImageViewWindowDelegate(myLocalViewWindowDelegateFunction);
            </code>
            </example>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.AcquisitionCount">
            <summary>
            Number of images to capture by Image Acquisition. Must be set before calling <c>StartImageAcquisition()</c>
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.EnablePacketResend">
            <summary>
            Enable Image Packet Resend in driver. Must be set before calling <c>StartImageAcquisition()</c>
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.PassCorruptFrames">
            <summary>
            Enable passing of corrupt frames from driver. Must be set before calling <c>StartImageAcquisition()</c>
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsGrabbing">
            <summary>
            Is the acquisition engine running?
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumFramesDelivered">
            <summary>
            This is the number of acquired frames since the last acquisition start.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumFramesLost">
            <summary>
            This is the number of lost frames due to a queue under-run. If the application is not emptying the acquisition queue as fast as the queue gets filled then the newly acquired frames will be dropped and this value will be increased by 1.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumBuffersAnnounced">
            <summary>
            This is the number of frame buffers that have been announced to the acquisition engine using J_DataStream_AnnounceBuffer(). This will be the maximum number of frame buffers in the system at any point in time.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <seealso cref="M:Jai_FactoryDotNET.Jai_FactoryWrapper.J_DataStream_AnnounceBuffer(System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr@)"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumFramesQueued">
            <summary>
            This is the number of frame buffers available and ready for image acquisition. When a new frame is acquired then it will be moved from this queue into the delivery queue and this value will be decreased by 1. The application can return the frame buffer to this queue using J_DataStream_QueueBuffer() after handling the new image delivery.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumFramesAwaitingDelivery">
            <summary>
            This is the number of frames that have been put into the delivery queue and are ready to be read and processed by the application. When the application gets the image using J_Event_GetData() then the frame buffer will automatically be removed from this delivery queue and the application then have to manually call J_DataStream_QueueBuffer() to return the buffer to the acquisition queue again.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.NumFramesCorruptOnDelivery">
            <summary>
            This is the number of frames which have been added to the delivery queue despite the fact that they are missing one or more packets. This will only happen if the EDataStreamParamCmd.PassCorruptFrames parameter has been set to true using J_DataStream_SetStreamParam().
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
            <exception cref="T:Jai_FactoryDotNET.Jai_FactoryWrapper.FactoryErrorException">Thrown if the internal call to Jai_FactoryWrapper.J_DataStream_GetStreamInfo() functions return an error</exception>
        </member>
        <member name="E:Jai_FactoryDotNET.CCamera.NewConnectionStatusDelegate">
            <summary>
            This delegate will be called for every change in Connection Status
            </summary>
            <example>
            <code>
            // To attach to the NewConnectionStatusDelegate you have to do like this:
            myCamera.NewConnectionStatusDelegate += new ConnectionStatusCallBack(myLocalConnectionStatusFunction);
            
            void myLocalNewConnectionStatusFunction(CCamera camera, Jai_FactoryWrapper.EDeviceConnectionType connectionStatus)
            {
                // Do something with the new connection status
            }
            
            // To remove the delegate again you have to do like this:
            myCamera.NewConnectionStatusDelegate -= new ConnectionStatusCallBack(myLocalNewConnectionStatusFunction);
            </code>
            </example>
        </member>
        <member name="E:Jai_FactoryDotNET.CCamera.GEVEventDelegate">
            <summary>
            This delegate will be called for every new GigE Vision event received from the camera
            </summary>
            <example>
            <code>
            // To attach to the GEVEventDelegate you have to do like this:
            myCamera.GEVEventDelegate += new GEVEventCallBack(myLocalGEVEventFunction);
            
            void myLocalGEVEventFunction(CCamera camera, UInt16 EventID, UInt16 StreamChannelIndex, UInt16 BlockID, UInt64 Timestamp, byte[] EventData)
            {
                // Do something with the new GigE Vision event
            }
            
            // To remove the delegate again you have to do like this:
            myCamera.GEVEventDelegate -= new GEVEventCallBack(myLocalGEVEventFunction);
            </code>
            </example>
        </member>
        <member name="E:Jai_FactoryDotNET.CCamera.NodeEventDelegate">
            <summary>
            This delegate will be called for every time a node callback has been called from GenICam node tree
            All nodes with an EventID associated will automatically get a callback registered
            </summary>
            <example>
            <code>
            // To attach to the NodeEventDelegate you have to do like this:
            myCamera.NodeEventDelegate += new NodeEventCallBack(myLocalNodeEventFunction);
            
            void myLocalNodeEventFunction(CNode node)
            {
                // Do something with the new Node event
            }
            
            // To remove the delegate again you have to do like this:
            myCamera.NodeEventDelegate -= new NodeEventCallBack(myLocalNodeEventFunction);
            </code>
            </example>
        </member>
        <member name="E:Jai_FactoryDotNET.CCamera.AsyncImageRecordingDoneEvent">
            <summary>
            This event will be called when asynchronous image recording has finished
            </summary>
            <example>
            <code>
            // To attach to the AsyncImageRecordingDoneHandler you have to do like this:
            myCamera.AsyncImageRecordDoneEvent += new CCamera.AsyncImageRecordingDoneHandler(myLocalRecordImageDoneFunction);
            
            void myLocalRecordImageDoneFunction(int count)
            {
                // Do something with the captured images
            }
            
            // To remove the event again you have to do like this:
            myCamera.AsyncImageRecordDoneEvent -= new CCamera.AsyncImageRecordingDoneHandler(myLocalRecordImageDoneFunction);
            </code>
            </example>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.AsyncImageRecordingSkipCount">
            <summary>
            Get the number of Images to be skipped during the recording. 
            
            The value 0 will record all frames. 
            The values 1 will record every second frame
            The values 2 will record every third frame
            ...
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.AsyncImageRecordingCount">
            <summary>
            Get number of Images to be recorded using the StartAsyncImageRecording() method
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.TotalAsyncImagesRecordedCount">
            <summary>
            Get total number of images already recorded using the StartAsyncImageRecording() method
            
            This number can be used for calculating the current Image Recording progress
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsAsyncImageRecordingRunning">
            <summary>
            Is the Asynchronous Image Recording running?
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.GetAsyncImageRecordingMode">
            <summary>
            Get the current Asynchronous Image Recording Mode
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ItemHandle">
            <summary>
            Handle to underlying transport layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.Name">
            <summary>
            Name of the interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.TLHandle">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IFHandle">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.LocalDevice">
            <summary>
            Handle to underlying interface layer
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.IsGeneric">
            <summary>
            Bool to show if camera is JAI or generic GenTL device.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.EnableMulticasting">
            <summary>
            Enable or disable multi-casting.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.MulticastIPAddress">
            <summary>
            Multi-cast address.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.AcquisitionBufferCount">
            <summary>
            Multi-cast address.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.DisplayName">
            <summary>
            DisplayName - Read-only property that returns "Name" for generic devices and "ModelName" + ", " + "MACAddress" for JAI cameras.
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.ManifestEntrySelector">
            <summary>
            Multi-cast address.
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.AsyncImageRecordingMode">
            <summary>
            Specify the asynchronous image recording mode.
            
            The supported types are either a List where the recording automatically stops when it is full
            or a Cyclic Buffer where the oldest image is automatically overwritten until the recording is stopped
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.AsyncImageRecordingMode.List">
            <summary>
            List of images. The recordings automatically stops after the specified number of images is recorded
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.AsyncImageRecordingMode.CyclicBuffer">
            <summary>
            Cyclic buffer. The recording automatically overwrites the oldest element
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.Command">
            
             <summary>
             Command class used for scripting feature settings
             </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Command.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Command.#ctor(System.String,System.Object)">
            <summary>
            Initializing constructor
            </summary>
            <param name="feature">GenICam feature name</param>
            <param name="value">Feature value to be stored</param>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.Command.FeatureName">
            <summary>
            GenICam feature name
            </summary>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.Command.FeatureValue">
            <summary>
            Value of the feature
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.Script">
            <summary>
            Script class used for feature value scripting
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Script.Clear">
            <summary>
            Empty the command list in the Script
            </summary>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Script.AppendDelay(System.Int32)">
            <summary>
            Append a delay to the end of the Script.
            </summary>
            <param name="DelayMs">Delay (in milliseconds) to be appended.</param>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Script.AppendStartImageAcquisition(System.Boolean,System.UInt32)">
            <summary>
            Append a StartImageAcquisition() command to the end of the Script.
            </summary>
            <param name="ShowWindow">Display the acquired images in a window or not.</param>
            <param name="BufferCount">Number of buffers to be allocated for the image acquisition.</param>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StartImageAcquisition(System.Boolean,System.UInt32)"/>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Script.AppendStopImageAcquisition">
            <summary>
            Append a StopImageAcquisition() command to the end of the Script.
            </summary>
            <seealso cref="M:Jai_FactoryDotNET.CCamera.StopImageAcquisition"/>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Script.LoadScript(System.String)">
            <summary>
            Load Script from disk
            </summary>
            <param name="Filename">Filename for the Script file</param>
            <returns>Script file. If the file cannot be loaded then this function returns 'null'.</returns>
        </member>
        <member name="M:Jai_FactoryDotNET.CCamera.Script.SaveScript(System.String,Jai_FactoryDotNET.CCamera.Script)">
            <summary>
            Save a Script to disk
            </summary>
            <param name="Filename">Filename of the Script file</param>
            <param name="script">Script to be saved</param>
        </member>
        <member name="P:Jai_FactoryDotNET.CCamera.Script.CommandList">
            <summary>
            List of commands to be executed
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.StreamWork">
            @} // End group CAM_SCRIPT_CLASSES
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.EDeviceClass">
            <summary>
            GigE Vision device class. This enumeration contains all valid Device Classes supported by GigE Vision 1.2 and higher
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.EDeviceClass.Transmitter">
            <summary>
            Transmitter. This is the default device class that typically is a camera
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.EDeviceClass.Receiver">
            <summary>
            Receiver. This is a device that is capable of receiving GVSP stream data
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.EDeviceClass.Transceiver">
            <summary>
            Transceiver. This is a device that is capable of both transmitting and receiving GVSP stream data. This is typically a device that is capable of doing real-time image processing on a GVSP stream from a camera and sending out the resulting stream to another Receiver.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.EDeviceClass.Peripheral">
            <summary>
            Peripheral. This is the device class without any stream capability - typically a GPIO device that for instance can be used as a strobe controller
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.ImageViewWindowDelegate">
            <summary>
            Delegate that will be called whenever a View Window event has been detected
            </summary>
            <param name="camera">CCamera object where this View Window event originates</param>
            <param name="Type">Type of View Window Event</param>
            <param name="CallbackValue">View Window Event value</param>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.RunScriptResult">
            <summary>
            Return value enumeration when running feature scripts.
            
            This enumeration is the return value from <c>RunScript()</c>.
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.Success">
            <summary>
            Success - everything OK
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.CameraNotOpen">
            <summary>
            Camera not open error
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.CameraReadOnly">
            <summary>
            Camera is opened as Read Only
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.ScriptAlreadyRunning">
            <summary>
            Script already running
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.UnableToLoadScript">
            <summary>
            Unable to load the Script from file
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.ValidationError">
            <summary>
            Error during validation of the script contents
            </summary>
        </member>
        <member name="F:Jai_FactoryDotNET.CCamera.RunScriptResult.ScriptCreateError">
            <summary>
            Unable to create the Script Thread
            </summary>
        </member>
        <member name="T:Jai_FactoryDotNET.CCamera.AsyncImageRecordingDoneHandler">
            <summary>
            This event is fired when the Asynchronous Image Recording is done
            </summary>
            <param name="Count">Number of images captured</param>
        </member>
    </members>
</doc>
